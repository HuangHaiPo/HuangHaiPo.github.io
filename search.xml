<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[史上最快用GitHub、Hexo搭建个人博客]]></title>
    <url>%2F2019%2F04%2F24%2F%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BF%AB%E7%94%A8GitHub%E3%80%81Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一. 准备工作 电脑一台(本文是基于Mac) 安装Git 安装Node.js GitHub账号一枚 如果读者电脑上已经装了git、Node、并且有GitHub账号，那么搭建个人博客绝对不超过抽一支烟的时间。 二. 安装git1. 在 Mac 上安装 Git，官方给了有两种方式。最容易的当属使用图形化的 Git 安装工具，界面如图，下载地址在下：Git GUI下载地址 2. 另一种是通过 MacPorts (http://www.macports.org) 安装。如果已经装好了 MacPorts，用下面的命令安装 Git：1$ sudo port install git-core +svn +doc +bash_completion +gitweb 译注：还有一种是使用 homebrew（https://github.com/mxcl/homebrew）：brew install git。 安装git官网教程 三. 安装Nodejs安装Nodejs也有两种方式GUI和终端命令 1. GUI下载地址Nodejs安装包下载地址 2. 终端执行命令先安装nvm，这是Nodejs版本管理器，可以轻松切换Nodejs版本。 curl方式安装nvm. 1$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash 下面是nvm部分输出，重点在最后，只有执行最后几条命令nvm才算安装完成。12345678910111213 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 11329 100 11329 0 0 4130 0 0:00:02 0:00:02 --:--:-- 4130=&gt; Downloading nvm from git to &apos;/Users/huanghaipo/.nvm&apos;=&gt; Initialized empty Git repository in /Users/huanghaipo/.nvm/.git/=&gt; Appending nvm source string to /Users/huanghaipo/.bashrc=&gt; bash_completion source string already in /Users/huanghaipo/.bashrc=&gt; Close and reopen your terminal to start using nvm or run the following to use it now://这里是执行命令export NVM_DIR=&quot;/Users/leon/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 根据提示执行命令load nvm,最后几条命令每个人的都不同。 123$ export NVM_DIR=&quot;/Users/leon/.nvm&quot;$ [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;$ nvm 使用nvm安装node1$ nvm install node 验证node及npm版本，如果有下方输出证明安装成功。 1234$ node -vv11.14.0$ npm -v6.7.0 四. 创建Github域名和仓库1. 注册GitHub账号注册Github账号，Username很重要，域名将是账号名加.github.io，username.github.io。 2. 创建仓库注册账号后我们需要创建一个存储网站数据的仓库，点击首页右上角加号，点击New repository按钮创建仓库。 Respository name 中的username.github.io 的username 一定与前面的Owner 一致，记住username后面会用到。 到此准备工作已经全部完成了。接下来就是安装hexo了。 五. 安装Hexo以上工作全部完成我们就可以安装Hexo了。一个崭新的博客将要出现。 1. 执行下方命令安装hexo1$ sudo npm install hexo-cli -g 安装完成后我们就可以初始化博客了，如果想要把文件放到某个目录下先cd到指定目录下在执行下方命令，如果没有指定目录默认是的你的个人主目录下。 12//username就是你刚才仓库的名称$ hexo init username.github.io 2. 配置博客设置初始化博客后我们需要修改配置文件已达到想要的效果如名字、主题等。 主题安装 为了美观我们安装一个火热的主题。先cd到刚才生成的目录下执行下方命令。12$ cd username.github.io$ git clone https://github.com/iissnan/hexo-theme-next themes/next 基础设置 找到_config.yml文件username.github.io/_config.yml修改下方基础配置保存修改。 注意_config.yml中配置项的冒号后面要用空格隔开，再跟内容否则启动服务时会报错。1234567title: huanghaipo //博客的名字author: huanghaipo //你的名字language: zh-Hans //语言 中文theme: next //刚刚安装的主题名称deploy:type: git //Github发布repo: https://github.com/username/username.github.io.git // 刚创建的Github仓库链接也可以选择ssh 3. 编写文章前期工作已近基本完成，接下来我们可以写文章了。发布就可以得到一枚个人博客，首先新建一个.md文件，命名为firstEssay.md，写入下方内容。放到username.github.io/source/_posts文件下。1234 --- title: 我的第一篇文章 ---**我的第一篇文章** 或者cd到你的博客文件夹执行下方命令行会得到一个md文件。 1hexo new post &quot;这是测试新建md文档&quot; //名字随便取 执行完以上命令，得到md文件，内容如下。12345---title: 这是测试新建md文档date: 2019-04-24 10:20:50 tags: //博客标签--- 4. 启动测试启动服务，直接浏览器中输入https://localhost:4000或者直接点击我 访问。1$ hexo s 5. 安装hexo-deployer-git自动部署发布工具1$ npm install hexo-deployer-git --save 6.发布以上步骤都完成后，我们就可以把生成的静态网页文件发布到Github上。以后直接通过连接就可以访问这个博客了。 12345$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d命令解释hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g //生成缓存和静态文件hexo d //重新部署到服务器 如果你使用的是HTTP可能会让你输入账号密码，输入正确后，稍等片刻，就会吧文件上传到Github上，然后直接访问刚才username.github.io就能看到自己的博客了。如果有新的文章只需要放到username.github.io/source/_posts下然后执行上面的命令就OK了。 最终效果 优化如果觉得这个主题不好看请或者想要更新博客更方便、更美观，请看这里。 hexo主题主题配置基础配置hexo插件 hexo常用命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 踩坑记录: 终端报错:1FATAL can not read a block mapping entry; a multiline key may not be an implicit key at line 70, column 1: ... 解决办法：_config.yml中配置项的冒号后面要用空格隔开，再跟内容 1出现 error deployer not found:git 或者 error deployer not found:github 的错误 解决办法：执行 npm install hexo-deployer-git –save 1中文乱码问题 解决办法：将文件的内容编码改为UTF8格式 1&apos;hexo sever&apos;能够成功运行，但是localhost:4000无法访问 解决办法：执行hexo s -p 5000，改用其他端口启动]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>个人博客</tag>
        <tag>GitHub Page</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客集成评论、文章阅读量功能]]></title>
    <url>%2F2019%2F04%2F23%2Fhexo%E5%8D%9A%E5%AE%A2%E9%9B%86%E6%88%90%E8%AF%84%E8%AE%BA%E3%80%81%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[神器:Valine 如果读者用的是Next主题同时是v5.1.4版本，那么很简单只需注册Valine账号生成id添加到主题配置文件中提交就OK。如果不是请结合这本篇文章看这篇就看我 这篇是集成文章阅读功能 目前大部分评论系统要么关闭服务要么是国外的服务会被墙，出现了Valine这个神器。 评论功能集成流程:1. 注册账号创建应用点击我去注册创建应用 Valine官网 2. 应用创建成功后点击存储 &gt; 创建Class 至于名字随自己喜好。 3. 所有的完成后，选择刚刚创建的应用&gt;设置&gt;选择应用 Key，然后你就能看到你的APP ID和APP KEY了，参考下图 4. 为了数据安全，请填写应用 &gt; 设置 &gt; 安全设置中的Web 安全域名，如下图： 如果想要加载速度更快把除了数据存储其他服务都关了。 主题_config配置12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true //false改为true appid: &apos;Your APP ID&apos;, // 这里填写上面得到的APP ID appkey: &apos;Your APP KEY&apos;, // 这里填写上面得到的APP KEY notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder//留言框占位提示文字 avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 关于评论功能邮件通知请看他Valine 评论系统中的邮件提醒设置 或者访问Valine官网 文章阅读量集成文章阅读量更简单。 如果在配置文件开启了阅读量统计，Valine 会自动检测 leancloud 应用中是否存在Counter类，如果不存在会自动创建，无需手动创建~。 或者自己手动创建Counter类然后把把app_id和app_key粘贴到主题配置文件中提交就OK了。 1234leancloud_visitors: enable: true app_id: &apos;Your APP ID&apos;, // 这里填写上面得到的APP ID app_key: &apos;Your APP KEY&apos;, // 这里填写上面得到的APP KEY PS:如果有问题给我留言]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客不蒜子统计不显示问题]]></title>
    <url>%2F2019%2F04%2F22%2Fhexo%E5%8D%9A%E5%AE%A2%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[新版的next主题已经把不蒜子集成进去，只需要打开开关即可，很方便如果不知道怎么设置请点击这个链接 里面有流程 不显示原因:不蒜子的域名跟换了但是next主题里面写进去的域名还是以前的，导致打开不蒜子统计，但是其实没有统计。 不蒜子官网 解决方法: 替换掉集成到next的失效域名，改为新的。路径为/theme/next/layout/_third-party/analytics/busuanzi-counter.swig 将失效域名替换为新的域名提交就OK了。新的域名&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>不蒜子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 添加分类及标签]]></title>
    <url>%2F2019%2F04%2F22%2FHexo%20%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[生成的新文件夹都在source下也就是和放文章的文件夹一块以下所有命令都是在博客文件目录下执行 1. 创建“分类”选项生成“分类”页并添加tpye属性,进入博客目录。执行命令下方命令 1$ hexo new page categories categories文件夹下会有index.md这个文件，打开后默认内容是这样的： 1234---title: categoriesdate: 2019-04-22 14:47:40--- 添加type: “categories”到内容中，添加后是这样的： 12345---title: 分类date: 2019-04-24 15:30:30type: categories--- 保存并关闭文件。 给文章添加“categories”属性 打开需要添加分类的文章，为其添加categories属性。下方的categories:Hexo表示这篇文章添加到到“Hexo”这个分类。注意：一篇文章只会添加到一个分类中，如果是多个默认放到第一个分类中。 12345---title: Hexo 添加分类及标签date: 2017-05-26 12:12:57categories: Hexo--- 至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。 2. 创建“标签”选项生成“标签”页并添加tpye属性 1$ hexo new page tags 在tags文件夹下，找到index.md这个文件，打开后默认内容是这样的： 1234---title: 标签date: 2019-04-22 14:22:08--- 添加type: “tags”到内容中，添加后是这样的： 12345---title: 标签date: 2019-04-24 15:40:24type: tags--- 保存并关闭文件。 给文章添加“tags”属性,打开需要添加标签的文章，为其添加tags属性。 12345678---title: Hexo 添加分类及标签date: 2019-04-24 15:40:24categories: - Hexotags: - 博客---]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIView添加阴影效果 四周或者单边阴影]]></title>
    <url>%2F2019%2F04%2F22%2FiOS%20UIView%E6%B7%BB%E5%8A%A0%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C%20%E5%9B%9B%E5%91%A8%E6%88%96%E8%80%85%E5%8D%95%E8%BE%B9%E9%98%B4%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[一般情况下设置阴影只需要设置layer就行，但是如果只是单边阴影，只设置layer效果不是多好，可以用贝塞尔曲线实现。 1. 直接设置layer阴影效果123456789101112UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 400, 50, 50)];imageView.layer.shadowColor = [UIColor redColor].CGColor;//剪切边界 如果视图上的子视图layer超出视图layer部分就截取掉 如果添加阴影这个属性必须是NO 不然会把阴影切掉imageView.layer.masksToBounds = NO;//阴影半径，默认3imageView.layer.shadowRadius = 3;//shadowOffset阴影偏移，默认(0, -3),这个跟shadowRadius配合使用imageView.layer.shadowOffset = CGSizeMake(0.0f,0.0f);// 阴影透明度，默认0imageView.layer.shadowOpacity = 0.9f;imageView.backgroundColor = [UIColor greenColor];[self.view addSubview:imageView]; 2. 利用贝塞尔曲线实现主要代码 123456789101112131415161718192021222324252627282930- (void)viewShadowPathWithColor:(UIColor *)shadowColor shadowOpacity:(CGFloat)shadowOpacity shadowRadius:(CGFloat)shadowRadius shadowPathType:(LeShadowPathType)shadowPathType shadowPathWidth:(CGFloat)shadowPathWidth&#123; self.layer.masksToBounds = NO;//必须要等于NO否则会把阴影切割隐藏掉 self.layer.shadowColor = shadowColor.CGColor;// 阴影颜色 self.layer.shadowOpacity = shadowOpacity;// 阴影透明度，默认0 self.layer.shadowOffset = CGSizeZero;//shadowOffset阴影偏移，默认(0, -3),这个跟shadowRadius配合使用 self.layer.shadowRadius = shadowRadius;//阴影半径，默认3 CGRect shadowRect = CGRectZero; CGFloat originX,originY,sizeWith,sizeHeight; originX = 0; originY = 0; sizeWith = self.bounds.size.width; sizeHeight = self.bounds.size.height; if (shadowPathType == LeShadowPathTop) &#123; shadowRect = CGRectMake(originX, originY-shadowPathWidth/2, sizeWith, shadowPathWidth); &#125;else if (shadowPathType == LeShadowPathBottom)&#123; shadowRect = CGRectMake(originY, sizeHeight-shadowPathWidth/2, sizeWith, shadowPathWidth); &#125;else if (shadowPathType == LeShadowPathLeft)&#123; shadowRect = CGRectMake(originX-shadowPathWidth/2, originY, shadowPathWidth, sizeHeight); &#125;else if (shadowPathType == LeShadowPathRight)&#123; shadowRect = CGRectMake(sizeWith-shadowPathWidth/2, originY, shadowPathWidth, sizeHeight); &#125;else if (shadowPathType == LeShadowPathCommon)&#123; shadowRect = CGRectMake(originX-shadowPathWidth/2, 2, sizeWith+shadowPathWidth, sizeHeight+shadowPathWidth/2); &#125;else if (shadowPathType == LeShadowPathAround)&#123; shadowRect = CGRectMake(originX-shadowPathWidth/2, originY-shadowPathWidth/2, sizeWith+shadowPathWidth, sizeHeight+shadowPathWidth); &#125; UIBezierPath *bezierPath = [UIBezierPath bezierPathWithRect:shadowRect]; self.layer.shadowPath = bezierPath.CGPath;//阴影路径&#125; 移步到GitHub项目地址)]]></content>
      <categories>
        <category>阴影效果</category>
      </categories>
      <tags>
        <tag>UIView阴影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 七牛批量、单张上传图片]]></title>
    <url>%2F2019%2F04%2F19%2FiOS%20%E4%B8%83%E7%89%9B%E6%89%B9%E9%87%8F%E3%80%81%E5%8D%95%E5%BC%A0%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[七牛目前只支持单张图片长传，多张图片上传的逻辑需要自己完成。 代码：GitHub项目地址 效果 使用方法: 传入获取token的URL； 获取到token后传给上传图片的方法中，成功后拼接图片链接，域名后台会给。 12345678 [HuUploadImgManage qiNiuUploadToken:@&quot;请求七牛token的URL&quot; success:^(NSString * _Nonnull token) &#123; [HuUploadImgManage uploadMuchImage:_pictureArray view:self.view token:kToken success:^(NSArray * _Nonnull imgArrayUrl) &#123; NSLog(@&quot;图片上传成功:%@&quot;,imgArrayUrl); &#125; failure:^(NSString * _Nonnull message) &#123; NSLog(@&quot;%@&quot;,message); &#125;]; &#125;];]]></content>
      <categories>
        <category>七牛</category>
      </categories>
      <tags>
        <tag>七牛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 时间字符串和时间戳使用]]></title>
    <url>%2F2019%2F03%2F22%2FiOS%20%E6%97%B6%E9%97%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%97%B6%E9%97%B4%E6%88%B3%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[时间字符串就是当前日期加时间，时间戳是从1970年到现在的秒数一、获取当前时间12345678//获取当前时间- (NSString *)currentDateStr&#123; NSDate *currentDate = [NSDate date];//获取当前时间，日期 NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];// 创建一个时间格式化对象 [dateFormatter setDateFormat:@&quot;YYYY/MM/dd hh:mm:ss&quot;];//设定时间格式,这里可以设置成自己需要的格式 NSString *dateString = [dateFormatter stringFromDate:currentDate];//将时间转化成字符串 return dateString;&#125; 二、获取当前时间戳 1234567//获取当前时间戳- (NSString *)currentTimeStr&#123; NSDate* date = [NSDate dateWithTimeIntervalSinceNow:0];//获取当前时间0秒后的时间 NSTimeInterval time=[date timeIntervalSince1970]*1000;// *1000 是精确到毫秒，不乘就是精确到秒 NSString *timeString = [NSString stringWithFormat:@&quot;%.0f&quot;, time]; return timeString;&#125; 三、时间戳转时间 12345678910// 时间戳转时间,时间戳为13位是精确到毫秒的，10位精确到秒- (NSString *)getDateStringWithTimeStr:(NSString *)str&#123; NSTimeInterval time=[str doubleValue]/1000;//传入的时间戳str如果是精确到毫秒的记得要/1000 NSDate *detailDate=[NSDate dateWithTimeIntervalSince1970:time]; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; //实例化一个NSDateFormatter对象 //设定时间格式,这里可以设置成自己需要的格式 [dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss SS&quot;]; NSString *currentDateStr = [dateFormatter stringFromDate: detailDate]; return currentDateStr;&#125; 四、字符串转时间戳 12345678//字符串转时间戳 如：2017-4-10 17:15:10- (NSString *)getTimeStrWithString:(NSString *)str&#123; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];// 创建一个时间格式化对象 [dateFormatter setDateFormat:@&quot;YYYY-MM-dd HH:mm:ss&quot;]; //设定时间的格式 NSDate *tempDate = [dateFormatter dateFromString:str];//将字符串转换为时间对象 NSString *timeStr = [NSString stringWithFormat:@&quot;%ld&quot;, (long)[tempDate timeIntervalSince1970]*1000];//字符串转成时间戳,精确到毫秒*1000 return timeStr;&#125;]]></content>
      <categories>
        <category>时间字符串</category>
      </categories>
      <tags>
        <tag>-时间字符串 -时间戳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算字符串宽度]]></title>
    <url>%2F2018%2F12%2F31%2F%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%BD%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[iOS 7.0之后sizeWithFont计算字符串的方法被弃用了用下面的方法代替123NSDictionary *attributes = [NSDictionary dictionaryWithObjectsAndKeys:[UIFont ipad_customFontWithName:@&quot;PingFangSC-Regular&quot; size:16.0f],NSFontAttributeName, nil];CGRect rect = [@&quot;宣教分类&quot; boundingRectWithSize:CGSizeMake(kTitleLabeW, kBtnWH) options:NSStringDrawingUsesLineFragmentOrigin attributes:attributes context:nil];NSLog(@&quot;%f==%f&quot;,rect.size.width,rect.size.height); 这是字符串的的实例方法，通过字符串调用该方法，会得到一个CGRect类型的对象，这个对象的的size就是计算的字符串显示成文本的宽高。CGSizeMake(kTitleLabeW, kBtnWH)(限制尺寸)用于计算文本绘制时占据的矩形块 kTitleLabeW 如果计算宽度 这个给个最大宽度 比如不说不能超过100.0f kTitleLabeW 值就是100.0f kBtnWH因为是计算宽度这个给个所计算控件的初始高度比如20.0f 反之如果计算高度 高度最大100.0f kBtnWH = 100.0f kTitleLabeW 就是默认不能超过的宽度，比如占全屏 去掉左右间隔就是最大宽度减去30 maxWidth-20 不过一般设置MAXFLOAT保证显示完整数据1234567891011121314151617181920options 枚举值 文本绘制时的选项typedef NS_OPTIONS(NSInteger, NSStringDrawingOptions) &#123; //通常使用NSStringDrawingUsesLineFragmentOrigin NSStringDrawingUsesLineFragmentOrigin = 1 &lt;&lt; 0, // 整个文本将以每行组成的矩形为单位计算整个文本的尺寸 // The specified origin is the line fragment origin, not the base line origin NSStringDrawingUsesFontLeading = 1 &lt;&lt; 1, // 使用字体的行间距来计算文本占用的范围，即每一行的底部到下一行的底部的距离计算 // Uses the font leading for calculating line heights NSStringDrawingUsesDeviceMetrics = 1 &lt;&lt; 3, // 将文字以图像符号计算文本占用范围，而不是以字符计算。也即是以每一个字体所占用的空间来计算文本范围 // Uses image glyph bounds instead of typographic bounds NSStringDrawingTruncatesLastVisibleLine // 当文本不能适合的放进指定的边界之内，则自动在最后一行添加省略符号。如果NSStringDrawingUsesLineFragmentOrigin没有设置，则该选项不生效 // Truncates and adds the ellipsis character to the last visible line if the text doesn't fit into the bounds specified. Ignored if NSStringDrawingUsesLineFragmentOrigin is not also set. &#125; attributes字符串字体大小字体格式1NSDictionary *dic= @&#123;[UIFont systemFontOfSize:14]: NSFontAttributeName&#125;;]]></content>
      <categories>
        <category>计算字符串宽度</category>
      </categories>
      <tags>
        <tag>字符串宽度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串操作截取匹配分割替换....]]></title>
    <url>%2F2018%2F12%2F29%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%88%AA%E5%8F%96%E5%8C%B9%E9%85%8D%E5%88%86%E5%89%B2%E6%9B%BF%E6%8D%A2....%2F</url>
    <content type="text"><![CDATA[1. 字符串截取12345678910111213141516171819202122232425262728293031323334353637383940414243NSString *tempStr = @"123456789";NSString *tempStr1 = [tempStr substringToIndex:5];//截取下标5之前的字符串NSLog(@"截取值为 == %@",tempStr1);NSString *tempStr2 = [tempStr substringFromIndex:5];//截取下标5之后的字符串NSLog(@"截取值为 == %@",tempStr2);输出：2018-12-29 15:24:44.734291+0800 compareDic[9389:721614] 截取值为 == 123452018-12-29 15:24:44.734425+0800 compareDic[9389:721614] 截取值为 == 6789处理字符串，使其首字母大写 字符串删除替换NSString *tempStr = @"abcdefghijklmn";NSString *resultStr;if (tempStr &amp;&amp; tempStr.length &gt; 0) &#123;//取字符串第一个 让其变成大写 resultStr = [tempStr stringByReplacingCharactersInRange:NSMakeRange(0,1) withString:[[tempStr substringToIndex:1] capitalizedString]];&#125;NSLog(@"%@", resultStr);输出2019-04-17 14:59:03.950001+0800 PICC[16043:778206] AbcdefghijklmnNSString *tempStr = @"abcdefghijklmn";NSString *resultStr;if (tempStr &amp;&amp; tempStr.length &gt; 0) &#123;//取最后一个字符串 删除 字母nresultStr = [tempStr stringByReplacingCharactersInRange:NSMakeRange(tempStr.length-1,1) withString:@""];&#125;NSLog(@"%@", resultStr);输出2019-04-17 14:57:21.395348+0800 PICC[15986:769010] abcdefghijklm//替换最后两个字符串NSString *tempStr = @"abcdefghijklmn";NSString *resultStr;if (tempStr &amp;&amp; tempStr.length &gt; 0) &#123;//取字符串第一个 让其变成大写resultStr = [tempStr stringByReplacingCharactersInRange:NSMakeRange(tempStr.length-2,2) withString:@"替换"];&#125;NSLog(@"%@", resultStr);输出2019-04-17 15:00:29.474159+0800 PICC[16075:786095] abcdefghijkl替换解释：NSMakeRange(tempStr.length-1, 1),将字符串tempStr.length定位到倒数第二个即‘m’，取长度为1的字符串，即m后第一个字符串 ‘n’，用字符串@“”替代‘n’，即所得的结果为“abcdefghijklm” 2. 字符串匹配或查找123456789101112NSString *tempStr3 = @"https://www.jianshu.com";NSRange range = [tempStr3 rangeOfString:@"www.ji"];//NSLog(@"range = %@",NSStringFromRange(range));tempStr3 = [tempStr3 substringWithRange:range];//匹配当前字符串是否有要查询的字符tempStr3 = [tempStr3 substringWithRange:NSMakeRange(3, 5)];//或者可以从第三个字符截取，截取到第五个字符NSLog(@"匹配值为 == %@",tempStr3);输出:2018-12-29 15:58:06.719612+0800 compareDic[9830:831378] range = &#123;8, 6&#125;2018-12-29 15:58:11.307964+0800 compareDic[9830:831378] 匹配值为 == www.ji2018-12-29 16:12:20.274156+0800 compareDic[10003:886465] 匹配值为 == ps:// rangeOfString方法意思:当前字符串https://www.jianshu.com是否包含某个字符www.ji，返回的是NSRange结构体。1234typedef struct _NSRange &#123; NSUInteger location; NSUInteger length;&#125; NSRange; 其中location意思是在www.ji中的第一个字符w在https://www.jianshu.com第几个位置答案是8。length意思是www.ji这个要查的字符串的长度，所以是6。 3. 字符串分割123456789NSString *tempStr = @&quot;https://www.jianshu.com&quot;;NSArray *cutArray = [tempStr componentsSeparatedByString:@&quot;//&quot;];//通过某个字符分割当前字符串，返回值一个数组NSLog(@&quot;分割字符串值为 = %@&quot;,cutArray);输出：2018-12-29 16:02:10.741299+0800 compareDic[9885:846881] 分割字符串值为 = ( &quot;https:&quot;, &quot;www.jianshu.com&quot;) 4.字符串替换1234567NSString *tempStr = @&quot;https://www.jianshu.com&quot;;//OfString不想要的字符串 withString想要 要替换的字符串NSString *replacedStr = [tempStr stringByReplacingOccurrencesOfString:@&quot;jianshu&quot; withString:@&quot;hangzhou&quot;];NSLog(@&quot;替换后的字符串 = %@&quot;,replacedStr);输出结果：2018-12-29 16:19:52.604515+0800 compareDic[10074:907022] 替换后的字符串 = https://www.zhejiang.com 5. 字符串验证1234567891011NSString *tempStr = @&quot;https://www.jianshu.com&quot;;//字符串是否已‘http’开头BOOL valBool = [tempStr hasPrefix:@&quot;http&quot;];//字符串是否已‘com’结尾BOOL valBool2 = [tempStr hasSuffix:@&quot;com&quot;];NSLog(@&quot;valBool = %d&quot;,valBool);NSLog(@&quot;valBool2 = %d&quot;,valBool2);输出：2018-12-29 16:30:02.814108+0800 compareDic[10201:948064] valBool = 12018-12-29 16:30:02.814244+0800 compareDic[10201:948064] valBool2 = 1 6. 字符串改变大小写1234567891011NSString *tempStr = @&quot;jiANshu&quot;;//全部转成大写NSString *changeStr = [tempStr uppercaseString];//全部转成小写NSString *changeStr2 = [tempStr lowercaseString];NSLog(@&quot;大写 = %@&quot;,changeStr);NSLog(@&quot;小写 = %@&quot;,changeStr2);输出：2018-12-29 16:35:15.880192+0800 compareDic[10292:970824] 大写 = JIANSHU2018-12-29 16:35:15.880321+0800 compareDic[10292:970824] 小写 = jianshu 7.字符串编码解码iOS 9.0之后，以前常用的NSString编码的方法stringByAddingPercentEscapesUsingEncoding:弃用了12345678910NSString *tempStr = @&quot;简书&quot;;//此方法意思：会编码字符串中非7-bit ASCII字符 （allowedCharacters）和要忽略的字符集 传的参数NSString *codeStr = [tempStr stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];NSString *noCodeStr = [codeStr stringByRemovingPercentEncoding];NSLog(@&quot;编码 = %@&quot;,codeStr);NSLog(@&quot;解码码 = %@&quot;,noCodeStr);输出：2018-12-29 16:41:03.717099+0800 compareDic[10406:999421] 编码 = %E7%AE%80%E4%B9%A62018-12-29 16:41:03.717278+0800 compareDic[10406:999421] 解码码 = 简书]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS支付三部曲之集成微信支付]]></title>
    <url>%2F2018%2F11%2F14%2FiOS%E6%94%AF%E4%BB%98%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E9%9B%86%E6%88%90%E5%BE%AE%E4%BF%A1%E6%94%AF%2F</url>
    <content type="text"><![CDATA[一. 微信支付步骤123451. 用户进入商户APP，选择商品下单、确认购买，进入支付环节。商户服务后台生成支付订单，签名后将数据传输到APP端。2. 用户点击后发起支付操作，进入到微信界面，调起微信支付，出现确认支付界面。3. 用户确认收款方和金额，点击立即支付后出现输入密码界面，可选择零钱或银行卡支付。4. 输入正确密码后，支付完成，用户端微信出现支付详情页面。5. 回跳到商户APP中，商户APP根据支付结果个性化展示订单处理结果。 二. 微信支付流程下图是微信开发者文档给的流程图 流程图看着繁琐其实具体就三步： app接入微信支付SDK，选中商品支付前调用后台给的接口接收调用微信支付需要的参数如tradeToken、orderInfo等。需要注意的是一般后台给的string字符串需要转成json。 拿到参数后调用微信支付API。 支付过后一般微信会有支付结果返回，但是安全起见让后台去验证支付是否成功。流程大概是上面三个步骤 三. 开发流程微信支付开发者文档 1. 集成微信支付SDK SDK下载地址 手动集成 将SDK拖到项目中点击项目选中Build Phases &gt; Link Binary With Libraries 添加依赖库。 过CocoaPods集成 在工程的Podfile里面添加以下代码： 1pod &apos;WechatOpenSDK&apos; 保存并执行pod install。 2. 设置URL Types选择你的工程设置项，选中“TARGETS”一栏，在“info”标签栏的“URL Types“添加“URL scheme”为你所注册的应用程序id Xcode设置URL scheme 3. 添加代码 AppDelegate 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [WXApi registerApp:@&quot;wx12312321312312&quot;];//注册appid&#125;- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url &#123; return [WXApi handleOpenURL:url delegate:[CdWeChatAPIManager sharedCdWeChatAPIManager]];&#125;// 配置系统回调接口- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; BOOL result = [UMSocialSnsService handleOpenURL:url]; if (result == FALSE) &#123; //调用其他SDK，例如支付宝SDK等 if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123; //跳转支付宝钱包进行支付，处理支付结果 [[AlipaySDK defaultService]processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123; [kNotificationCenter postNotificationName:kAlibabaPaymentStatus object:resultDic];//发起通知处理支付结果 &#125;]; return YES; &#125; return [WXApi handleOpenURL:url delegate:[CdWeChatAPIManager sharedCdWeChatAPIManager]]; &#125; return result;&#125;// NOTE: 9.0以后使用新API接口- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options&#123; BOOL result = [UMSocialSnsService handleOpenURL:url]; if (result == false) &#123; if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123; //跳转支付宝钱包进行支付，处理支付结果 [[AlipaySDK defaultService]processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123; [kNotificationCenter postNotificationName:kAlibabaPaymentStatus object:resultDic];//发起通知处理支付结果 &#125;]; return YES; &#125; return [WXApi handleOpenURL:url delegate:[CdWeChatAPIManager sharedCdWeChatAPIManager]]; &#125; return result;&#125; delegate的类根据自己的需求可以自定义，目前我们项目时这样写的。获取到支付回调后请求后台验证接口，验证支付是否成功。需要注意的是设置过代理后需要遵守微信协议WXApiDelegate关于集成支付宝在下篇文章传送门 回调单例类CdWeChatAPIManager 1234567891011121314151617181920212223242526272829303132333435.h@protocol CdWeChatAPIManagerDelegate &lt;NSObject&gt;@optional- (void)managerDidRecvAuthBaseResp:(BaseResp *)response;@end@interface CdWeChatAPIManager : NSObject &lt;WXApiDelegate&gt;@property (nonatomic, weak) id&lt;CdWeChatAPIManagerDelegate&gt; delegate;singleton_interface(CdWeChatAPIManager);@end@implementation CdWeChatAPIManagersingleton_implementation(CdWeChatAPIManager);#pragma mark - WXApiDelegate- (void)onResp:(BaseResp *)resp &#123; if([resp isKindOfClass:[PayResp class]])&#123; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(managerDidRecvAuthBaseResp:)]) &#123; [self.delegate managerDidRecvAuthBaseResp:resp]; &#125; &#125;&#125;- (void)onReq:(BaseReq *)req &#123;&#125;@end 处理微信支付回调结果 在需要展示的地方遵守协议 12345678910- (void)managerDidRecvAuthBaseResp:(BaseResp *)response&#123; [[CdPaymentCenter sharedCdPaymentCenter].hud hide:YES]; if (response.errCode == 0) &#123; //调用后台验证支付是否成功接口 验证完成后微信支付基本算完成了。 &#125;else if (response.errCode == -1)&#123; [self paymentFailure:@&quot;支付失败&quot;]; &#125;else if(response.errCode == -2)&#123; [self paymentFailure:@&quot;支付取消&quot;]; &#125;&#125; 回调中errCode值列表： 名称 描述 解决方案 0 成功 展示成功页面 -1 错误 可能的原因：签名错误、未注册APPID、项目设置APPID不正确、注册的APPID与设置的不匹配、其他异常等。 -2 用户取消 无需处理。发生场景：用户不支付了，点击取消，返回APP。 写在最后 关于掉单问题目前我们的解决办法是每调起支付会创建一个事件放到数据库中，如果正常情况支付完成了会把数据删了如果发生断网，关机等情况，有网时或者开机。会检测数据库是否有未完成的订单去后台查询支付是否完成，商品是否购买成功。 关于签名问题最好是让后台去做不要APP端完成，不然风险太大。 关于调微信支付的参数：签名APPID等是根据某个字符分开的，取到后需要自己拼。 关于注册APPID问题产品或者运营一般都弄好了如果自己申请网站申请后需要微信审核。]]></content>
      <categories>
        <category>微信支付</category>
      </categories>
      <tags>
        <tag>集成微信支付</tag>
        <tag>第三方支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 防止UIButton暴力点击]]></title>
    <url>%2F2018%2F09%2F14%2FiOS%20%E9%98%B2%E6%AD%A2UIButton%E6%9A%B4%E5%8A%9B%E7%82%B9%E5%87%BB%2F</url>
    <content type="text"><![CDATA[每次在点击时先取消之前的操作 12345678910- (void)buttonClick:(UIButton *)violenceBtn&#123; //点击按钮后先取消之前的操作，再进行需要进行的操作 [[self class] cancelPreviousPerformRequestsWithTarget:self selector:@selector(handleClickEvent:) object:violenceBtn]; [self performSelector:@selector(handleClickEvent:) withObject:violenceBtn afterDelay:0.5f];//时间0.5&#125;//点击事件的处理方法- (void)handleClickEvent:(UIButton *)btn&#123; NSLog(@&quot; %s &quot;,__FUNCTION__);&#125; 点击后设为不可被点击的状态，几秒后恢复 12345678-(void)buttonClick:(UIButton*)violenceBtn&#123; violenceBtn.enabled =NO; NSLog(@&quot; %s &quot;,__FUNCTION__); [self performSelector:@selector(changeButtonStatus) withObject:nil afterDelay:1.0f];//防止重复点击&#125;-(void)changeButtonStatus&#123; _btn.enabled =YES;&#125; 通过点击间隔时间防止暴力点击 123456789-(void)buttonClick:(UIButton*)violenceBtn&#123; static NSTimeInterval time = 0.0; NSTimeInterval currentTime = [NSDate date].timeIntervalSince1970;//防止暴力点击 两秒内只能点击一次 if (currentTime - time &gt; 2) &#123;//限制用户点击按钮的时间间隔大于2秒钟 NSLog(@&quot; %s &quot;,__FUNCTION__); &#125; time = currentTime;&#125; 使用runtime,把按钮的点击方法进行替换来设置时间间隔。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** 防止按钮重复暴力点击 */@interface UIButton (ViolenceBtn)//点击间隔@property (nonatomic, assign) NSTimeInterval timeInterval;//用于设置单个按钮不需要被hook (设为yes说明可以重复点击)@property (nonatomic, assign) BOOL isIgnore;@end#import &quot;UIButton+ViolenceBtn.h&quot;#import &lt;objc/runtime.h&gt;//默认时间间隔#define defaultInterval 1@implementation UIButton (ViolenceBtn)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; SEL orginalSel = @selector(sendAction:to:forEvent:); SEL swizzledSel = @selector(sure_SendAction:to:forEvent:); //原有方法 Method originalMethod = class_getInstanceMethod(class, orginalSel); //替换原有方法的新方法 Method swizzledMethod = class_getInstanceMethod(class, swizzledSel); //先尝试給源SEL添加IMP，这里是为了避免源SEL没有实现IMP的情况 //将methodB的实现添加到系统方法中也就是说将methodA方法指针添加成方法methodB的返回值表示是否添加成功 BOOL didAddMethod = class_addMethod(class, orginalSel, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); //添加成功了说明本类中不存在methodB所以此时必须将方法b的实现指针换成方法A的，否则b方法将没有实现。 if (didAddMethod) &#123; //添加成功：说明源SEL没有实现IMP，将源SEL的IMP替换到交换SEL的IMP class_replaceMethod(class, swizzledSel, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; //添加失败：说明源SEL已经有IMP，直接将两个SEL的IMP交换即可 //添加失败了说明本类中有methodB的实现，此时只需要将methodA和methodB的IMP互换一下即可。 method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;- (NSTimeInterval)timeInterval &#123; return [objc_getAssociatedObject(self, _cmd) doubleValue];&#125;- (void)setTimeInterval:(NSTimeInterval)timeInterval &#123; objc_setAssociatedObject(self, @selector(timeInterval), @(timeInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;//当按钮点击事件sendAction 时将会执行sure_SendAction- (void)sure_SendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123; if (self.isIgnore) &#123; //不需要被hook [self sure_SendAction:action to:target forEvent:event]; return; &#125; if ([NSStringFromClass(self.class) isEqualToString:@&quot;UIButton&quot;]) &#123; self.timeInterval = self.timeInterval == 0 ? defaultInterval : self.timeInterval; if (self.isIgnoreEvent) &#123; return; &#125; else if (self.timeInterval &gt; 0) &#123; [self performSelector:@selector(resetState) withObject:nil afterDelay:self.timeInterval]; &#125; &#125; //此处 methodA和methodB方法IMP互换了，实际上执行 sendAction；所以不会死循环 self.isIgnoreEvent = YES; [self sure_SendAction:action to:target forEvent:event];&#125;//runtime 动态绑定 属性- (void)setIsIgnoreEvent:(BOOL)isIgnoreEvent &#123; // 注意BOOL类型 需要用OBJC_ASSOCIATION_RETAIN_NONATOMIC 不要用错，否则set方法会赋值出错 objc_setAssociatedObject(self, @selector(isIgnoreEvent), @(isIgnoreEvent), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (BOOL)isIgnoreEvent &#123; //_cmd == @select(isIgnore); 和set方法里一致 return [objc_getAssociatedObject(self, _cmd) boolValue];&#125;- (void)setIsIgnore:(BOOL)isIgnore &#123; // 注意BOOL类型 需要用OBJC_ASSOCIATION_RETAIN_NONATOMIC 不要用错，否则set方法会赋值出错 objc_setAssociatedObject(self, @selector(isIgnore), @(isIgnore), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (BOOL)isIgnore&#123; //_cmd == @select(isIgnore); 和set方法里一致 return [objc_getAssociatedObject(self, _cmd) boolValue];&#125;- (void)resetState&#123; [self setIsIgnoreEvent:NO];&#125;@end 目前来说通过runtime最方便，但是如果是不同按钮同时点击情况还会发生，所以可以使用最合适的方法。]]></content>
      <categories>
        <category>UIButton</category>
      </categories>
      <tags>
        <tag>UIButton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 设置.gitignore文件 忽略.DS_Store 、xcuserstate等文件]]></title>
    <url>%2F2018%2F06%2F22%2FiOS%20%E8%AE%BE%E7%BD%AE.gitignore%E6%96%87%E4%BB%B6%20%E5%BF%BD%E7%95%A5.DS_Store%20%E3%80%81xcuserstate%E7%AD%89%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[开发项目时会有一些文件一直自动更新但是不必提交的文件如版本管理文件,如果不忽略提交代码时会遇到下方报错。比如xcuserstate文件,这个文件会实时更新不管有没有更改过代码等，此文件保存的是项目的状态之类的，不需要提交。123The working copy “项目名称” has uncommitted changes.Commit or discard the changes and try again. 此时需要配置git的.gitignore文件忽略掉不需要提交的文件。 1. 设置项目中的.gitignore文件。.gitignore文件是隐藏文件需要显示隐藏文件才能看到，终端执行下方命令可以显示隐藏文件。有没有大神知道显示隐藏文件的快捷键。 1defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder 创建.gitignore文件，首先进入到项目目录下执行下面终端命令1touch .gitignore 打开编辑忽略配置文件1open .gitignore 直接通过命令打开或者找到此文件直接双击打开用文本编辑器或者其他编辑器都可以，然后把下面代码(需要忽略的文件)粘贴进去保存提交到远端就OK了。以后提交就不会出现上面的问题。或者点击 GitHub Objective-C.gitignore项目地址 objc-c项目在GitHub上.gitignore地址12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 # ---&gt; Objective-C# Xcode## gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore##file*.app.dSYM.zip.DS_Store## Build generatedbuild/DerivedData## .DS_store*.DS_Store.DS_Store.DS_Store?*.swp*.swo## Various settings*.pbxuser!default.pbxuser*.mode1v3!default.mode1v3*.mode2v3!default.mode2v3*.perspectivev3!default.perspectivev3xcuserdata## Other*.xccheckout*.moved-aside*.xcuserstate*.xcscmblueprint## Obj-C/Swift specific*.hmap*.ipa# CocoaPods## We recommend against adding the Pods directory to your .gitignore. However# you should judge for yourself, the pros and cons are mentioned at:# http://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control##Pods/# Carthage## Add this line if you want to avoid checking in source code from Carthage dependencies.# Carthage/CheckoutsCarthage/Build 2. 在SourceTree中设置.gitignore文件。SourceTree的偏好设置里面有一个可以设置.gitignore文件选项，可以直接在里面设置忽略文件，优点是只要是使用SourceTree提交代码就可以自动忽略，不用每个项目在设置忽略文件。 写在最后 Git忽略规则(.gitignore配置）不生效原因和解决 第一种方法:.gitignore中已经标明忽略的文件目录下的文件，git push的时候还会出现在push的目录中，或者用git status查看状态，想要忽略的文件还是显示被追踪状态。原因是因为在git忽略目录中，新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行git的提交，这样就不会出现忽略的文件了。 解决方法: 进入项目对应路径清除git本地缓存（改变成未track状态），然后再提交: 1234git rm -r --cached .git add .git commit -m &apos;update .gitignore&apos;git push -u origin master 需要特别注意的是： gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。 想要.gitignore起作用，必须要在这些文件不在暂存区中才可以，.gitignore文件只是忽略没有被staged(cached)文件，对于已经被staged文件，加入ignore文件时一定要先从staged移除，才可以忽略。 第二种方法:（推荐）在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。1git update-index --assume-unchanged PATH //在PATH处输入要忽略的文件]]></content>
      <categories>
        <category>.gitignore</category>
      </categories>
      <tags>
        <tag>.gitignore</tag>
        <tag>忽略文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 后台返回json解析出现的null的解决办法]]></title>
    <url>%2F2017%2F08%2F30%2FiOS%20%E5%90%8E%E5%8F%B0%E8%BF%94%E5%9B%9Ejson%E8%A7%A3%E6%9E%90%E5%87%BA%E7%8E%B0%E7%9A%84null%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在后台返回值为Null为空时，我们代码没有判断时，程序就会崩溃。当时一直很疑惑是为啥，后来发现是数据问题，由于服务器的数据库中有些字段为空，然后以Json形式返回给客户端时就会出现这样的数据。当我们通过一些第三方数据解析库解析数据后，就会是下图这种数据格式。null既不是字符串也不是nil所以我们有些判断是没用的。解析成对象之后，如果直接向这个对象发送消息(length,count 等等)就会直接崩溃。提示错误为1-[NSNull length]: unrecognized selector sent to instance 0x388a4a70 ##解决办法1.对取值对象类型判断。缺点是太过繁琐，每次都要写。 1234#define kDictIsEmpty(dic) ([dic isKindOfClass:[NSNull class]])//宏 if (![@&quot;你要取的值&quot; isKindOfClass:[NSNull class]])&#123;//数据&#125; 2.字符串匹配。在获取到服务器返回的Json时(返回结果是string对象)通过stringByReplacingOccurrencesOfString方法，替换”null”为”空字符”，然后解析。不过通过这个方法也有可能导致数据无法解析1json = [jsonStr stringByReplacingOccurrencesOfString:@&quot;:null&quot; withString:@&quot;&quot;]; 3.解析时把null 类型替换成nil。12345678910111213//有返回值的宏#define isToNull(value) \(&#123;\ id tmp;\ if (![value isKindOfClass:[NSNull class]])\ tmp = value;\ else tmp = nil;\ (tmp);\&#125;)\//调用方法label.text = isToNull(dic[@&quot;data&quot;]); 4.如果使用是AFNetwork做网络请求的话，可以用以下代码，会自动去除空值1234AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];AFJSONResponseSerializer *response = [AFJSONResponseSerializer serializer];response.removesKeysWithNullValues = YES;//去除空值manager.responseSerializer = response;//申明返回的结果是json类 去除前去除后 所有为空的键值对都会被自动去除 5.最有效而且简单的方法。使用国外一位大牛写的Category，叫做NullSafe ，在运行时操作，把空值置为nil，而nil是安全的，可以向nil对象发送任何message而不会奔溃。具体使用方法项目有说明 NullSafe链接]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 内购遇到的坑]]></title>
    <url>%2F2017%2F07%2F24%2FiOS%20%E5%86%85%E8%B4%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[####一.内购沙盒测试账号在支付成功后，再次购买相同 ID 的物品，会提示如下内容的弹窗。您以购买过此APP内购项目，此项目将免费恢复 #####原因:当使用内购购买过商品后没有把这个交易事件关，所以当我们再次去购买商品后就会调用以前已经购买成功的交易事件去购买因为已经购买过，才会有这个提示 #####解决方法：1.当我们使用[[SKPaymentQueue defaultQueue] addPayment:payment];这个方法进行支付请求后，因为我们已经把支付所需要的信息都添加到苹果的支付队列，苹果会自动完成后续的购买请求。在用户购买成功或者点击取消购买的后会回调- (void)paymentQueue:(SKPaymentQueue )queue updatedTransactions:(NSArray )transaction;方法返回响应的结果信息，在该方法内除了得到响应的支付信息编写自身的业务的代码外还要记得调用[[SKPaymentQueue defaultQueue] finishTransaction:transaction];方法通知苹果的支付队列该交易已经完成，否者就会调用已经购买成功的支付队列，就会出现您以购买过此APP内购项目，此项目将免费恢复这句提示。123456789101112131415161718192021222324252627282930313233- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray&lt;SKPaymentTransaction *&gt; *)transactions&#123; NSLog(@&quot;调用了几次这个方法？&quot;); SKPaymentTransaction *transaction = transactions.lastObject; switch (transaction.transactionState) &#123; case SKPaymentTransactionStatePurchased: &#123; [[SKPaymentQueue defaultQueue] finishTransaction:transaction];//记得关闭交易事件 NSLog(@&quot;购买完成,向自己的服务器验证 ---- %@&quot;, transaction.payment.applicationUsername); NSData *data = [NSData dataWithContentsOfFile:[[[NSBundle mainBundle] appStoreReceiptURL] path]]; NSString *receipt = [data base64EncodedStringWithOptions:0];// [self buySuccessWithReceipt:receipt transaction:transaction]; &#125; break; case SKPaymentTransactionStateFailed: &#123; NSLog(@&quot;交易失败&quot;); [[SKPaymentQueue defaultQueue] finishTransaction:transaction]; &#125; break; case SKPaymentTransactionStateRestored: &#123; NSLog(@&quot;已经购买过该商品&quot;); [[SKPaymentQueue defaultQueue] finishTransaction:transaction]; &#125; break; case SKPaymentTransactionStatePurchasing: &#123; NSLog(@&quot;商品添加进列表&quot;); &#125; break; default: &#123; NSLog(@&quot;这是什么情况啊？&quot;); &#125; break; &#125;&#125; ######2.在买次购买之前检测是否有未完成的交易如果有就关闭。 123456789NSArray* transactions = [SKPaymentQueue defaultQueue].transactions; if (transactions.count &gt; 0) &#123; //检测是否有未完成的交易 SKPaymentTransaction* transaction = [transactions firstObject]; if (transaction.transactionState == SKPaymentTransactionStatePurchased) &#123; [[SKPaymentQueue defaultQueue] finishTransaction:transaction]; return; &#125; &#125; ####二.内购 元数据丢失 ######一般情况下是需要填的选项没有填写完整，还有要填写完整不然审核内购项目可能会不通过。 ####三.iOS 内购 您已经购买了此项目，您想免费再获取一次吗这个是内购选择类型不匹配原因导致。非消耗型就是消耗一次后在该appid下都能使用。消耗型比如一些直播平台的货币 使用完以后可以在充值。我有这个问题是 最开始我们的项目是购买完产品以后可以永久使用，后来修改成充值余额购买，但是我没有去修改类型才导致的这个错误， ####四.测试时记得把App Store上的账号注销，不然会出现购买失败，注销账号后，在进行内购时登录沙盒测试账号。 ####五.In-App Purchase二次验证IOS在沙箱环境下购买成功之后，向苹果进行二次验证，确认用户是否购买成功。当应用向Apple服务器请求购买，成功之后，Apple会返回以下四个数据给应用 产品标识符: product Identifier[在itunes store应用内定义的产品ID，例如com.公司名.产品名.道具名(com.xxxx.317hu.66)] 交易状态: state Receipt:很长的一段字符串，大概49行，作为二次验证的重要依据 交易标识符: transaction Identifier 我们需要把Receipt发送給苹果的苹果的服务器验证，用户的购买信息是否真实 交易状态 解释 Purchased 购买成功 Restored 恢复购买 Failed 失败 Deferred 等待确认，儿童模式需要询问家长同意 苹果返回状态码 状态码 状态 描述 21000 App Store不能读取你提供的JSON对象 21002 receipt-data域的数据有问题 21003 receipt无法通过验证 21004 提供的shared secret不匹配你账号中的shared secret 21005 receipt服务器当前不可用 21006 receipt合法，但是订阅已过期。服务器接收到这个状态码时，receipt数据仍然会解码并一起发送 21007 receipt是Sandbox receipt，但却发送至生产系统的验证服务 21008 receipt是生产receipt，但却发送至Sandbox环境的验证服务]]></content>
      <categories>
        <category>内购</category>
      </categories>
      <tags>
        <tag>内购</tag>
        <tag>IAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS内购图文流程(2017)]]></title>
    <url>%2F2017%2F06%2F20%2FiOS%E5%86%85%E8%B4%AD%E5%9B%BE%E6%96%87%E6%B5%81%E7%A8%8B(2017)%2F</url>
    <content type="text"><![CDATA[#什么是内购？ ######只要在iPhone App上购买的不是实物产品(也就是虚拟产品如qq币.虎牙币.电子书……) 都需要走内购流程,苹果在里面抽走三成。 #使用内购需要走的流程。 1,填写协议,税务和银行业务;2,填写用户和职能; 创建内购的项目3,写代码,和后台配合4,添加项目内购测试账号;检验成果#具体步骤： ###接下来的步骤特别繁琐，请做好准备。 一.填写协议,税务和银行业务配置 https://itunesconnect.apple.com ##1.请求合同 ###填写地址信息 ###阅读同意协议 ##2.填写联系方式 ###添加新的联系人 ###选中联系人 ##3.填写银行信息 ###添加银行卡 ###选择银行卡所在国家 ###填写银行CNAPS Code货币类型 CN###银行账号如果是对公的账号，需要填写公司的英文名称，如果没有的话拼音 ##4.填写税务信息U.S Tax Forms: 美国税务Australia Tax Forms：澳大利亚税务Canada Tax Forms: 加拿大税务第一个问题如下：询问你是否是美国居民，有没有美国伙伴关系或者美国公司，如果没有直接选择No。第二个问题如下：询问你有没有在美国的商业性活动，没有也直接选No ###然后填写你的税务信息，包括以下几点：Individual or Organization Name：个人或者组织名称Country of incorporation： 所在国家Type of Beneficial Owner：受益方式，独立开发者选个人Permanent Residence：居住地址Mailing address：邮寄地址Name of Person Making this Declaration：声明人Title：头衔 ###填写完这些信息后就可以提交了 ##5.等待审核,时间24小时左右。 #二.创建内购项目 ###选中你要添加内购项目的APP然后点击功能,点击+创建内购项目。 ###根据自己APP的需求选择类型 ###填写项目名称id (ps:应用在首次添加内购买项目时需要与新的应用版本一起提交审核。) ###添加沙盒技术测试员 ###用户职能&gt;沙箱技术测试员 ##注意事项: ###邮箱随便写但是格式要正确(test@163.com)，但是不能用已经是AppleID的邮箱 ###App Store 地区不要乱选。虽然随便哪个地区都可以用来测试（还没上线之前app并没有地区之分），但是在沙盒测试的时候，弹出的购买提示框会根据当前AppleID(沙盒账号)的地区显示语言的。 ###使用沙盒测试一定要用真机 (越狱的不行) ###沙盒账号不能直接登录AppleStore登录时会提示”不允许创建iTunes账户” ###进行沙盒测试时需要退出AppleStore的账号 #三.代码12345678910111213141516171819202122#import &lt;Foundation/Foundation.h&gt;#import &quot;WXApi.h&quot;typedef NS_ENUM(NSInteger , Payment) &#123; IAP6 = 6, IAP25 = 25, IAP60 = 60&#125;;@interface PayCenter : NSObjectsingleton_interface(PayCenter);- (void)startInit;- (void)payWithMoney:(NSInteger)money andType:(PayType)type dataDic:(NSDictionary *)dataDic;@property (nonatomic, strong) MBProgressHUD * hud;@property (nonatomic, copy) NSString * rechargeNumber;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#define kProductID_IAP6 @&quot;org.qqhl.nursning.6&quot;//6#import &quot;PayCenter.h&quot;#import &quot;PayHttpRequest.h&quot;//#import &quot;Order.h&quot;//#import &quot;DataSigner.h&quot;//#import &lt;AlipaySDK/AlipaySDK.h&gt;#import &lt;StoreKit/StoreKit.h&gt;@interface PayCenter()&lt;SKPaymentTransactionObserver,SKProductsRequestDelegate&gt;&#123; int buyType; NSInteger _money;&#125;@property (nonatomic, strong) NSMutableDictionary * dataDic;@end@implementation PayCentersingleton_implementation(PayCenter);- (void)startInit&#123; [WXApi registerApp:kWeChatShareAppKey withDescription:appDefaultTilte];&#125;- (void)payWithMoney:(NSInteger)money andType:(PayType)type dataDic:(NSDictionary *)dataDic&#123; _money = money; self.dataDic = [NSMutableDictionary dictionaryWithDictionary:dataDic]; switch (type) &#123; case PayTypeWX: [self payTypeWXPay]; break; case ApplePay:// [self payTypeAliPay]; [[SKPaymentQueue defaultQueue]addTransactionObserver:self]; if ([SKPaymentQueue canMakePayments]) &#123; HULog(@&quot;允许程序内付费购买&quot;); [self payTypeApplePay]; &#125;else &#123; HULog(@&quot;不允许程序内付费购买&quot;); UIAlertView *alerView = [[UIAlertView alloc] initWithTitle:@&quot;提示&quot; message:@&quot;您的手机没有打开程序内付费购买&quot; delegate:nil cancelButtonTitle:NSLocalizedString(@&quot;关闭&quot;,nil) otherButtonTitles:nil]; [alerView show]; &#125; break; default: break; &#125;&#125;- (void)payTypeApplePay&#123; NSLog(@&quot;---------请求对应的产品信息------------&quot;); NSArray *product = nil; switch (_money) &#123; case IAP6: &#123; product=[[NSArray alloc] initWithObjects:kProductID_IAP6,nil]; NSLog(@&quot;---------IAP6------------&quot;); &#125; break; case IAP25: &#123; NSLog(@&quot;---------IAP25------------&quot;); &#125; break; case IAP60: &#123; NSLog(@&quot;---------IAP60------------&quot;); &#125; break; default: break; &#125; NSSet *nsSet = [NSSet setWithArray:product]; SKProductsRequest *request = [[SKProductsRequest alloc]initWithProductIdentifiers:nsSet]; request.delegate = self; [request start];&#125;#pragma mark - SKProductsRequestDelegate代理//返回的在苹果服务器请求的产品信息- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response&#123; HULog(@&quot;收到产品信息&quot;); NSArray *myProduct = response.products; HULog(@&quot;产品id %@&quot;,response.invalidProductIdentifiers); NSLog(@&quot;产品付费数量%d&quot;,(int)[myProduct count]);//populate UI for (SKProduct *product in myProduct) &#123; NSLog(@&quot;product info&quot;); NSLog(@&quot;SKProduct 描述信息%@&quot;, [product description]); NSLog(@&quot;产品标题 %@&quot; , product.localizedTitle); NSLog(@&quot;产品描述信息: %@&quot; , product.localizedDescription); NSLog(@&quot;价格: %@&quot; , product.price); NSLog(@&quot;Product id: %@&quot; , product.productIdentifier); &#125; SKPayment *payment = nil; switch (_money) &#123; case IAP6: &#123; payment = [SKPayment paymentWithProductIdentifier:kProductID_IAP6]; &#125; break; case IAP25:&#123; &#125; default: break; &#125; NSLog(@&quot;发起购买请求&quot;); [[SKPaymentQueue defaultQueue]addPayment:payment]; &#125;//实现监听方法- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray&lt;SKPaymentTransaction *&gt; *)transactions&#123; NSLog(@&quot;调用了几次这个方法？&quot;); SKPaymentTransaction *transaction = transactions.lastObject; switch (transaction.transactionState) &#123; case SKPaymentTransactionStatePurchased: &#123; NSLog(@&quot;购买完成,向自己的服务器验证 ---- %@&quot;, transaction.payment.applicationUsername); NSData *data = [NSData dataWithContentsOfFile:[[[NSBundle mainBundle] appStoreReceiptURL] path]]; NSString *receipt = [data base64EncodedStringWithOptions:0];// [self buySuccessWithReceipt:receipt transaction:transaction]; &#125; break; case SKPaymentTransactionStateFailed: &#123; NSLog(@&quot;交易失败&quot;); [[SKPaymentQueue defaultQueue] finishTransaction:transaction]; &#125; break; case SKPaymentTransactionStateRestored: &#123; NSLog(@&quot;已经购买过该商品&quot;); [[SKPaymentQueue defaultQueue] finishTransaction:transaction]; &#125; break; case SKPaymentTransactionStatePurchasing: &#123; NSLog(@&quot;商品添加进列表&quot;); &#125; break; default: &#123; NSLog(@&quot;这是什么情况啊？&quot;); &#125; break; &#125;&#125;@end ####购买成功后需要跟服务器交互验证交易是否成功123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 验证凭据，获取到苹果返回的交易凭据 // appStoreReceiptURL iOS7.0增加的，购买交易完成后，会将凭据存放在该地址 NSURL *receiptURL = [[NSBundle mainBundle] appStoreReceiptURL]; // 从沙盒中获取到购买凭据 NSData *receipt = [NSData dataWithContentsOfURL:receiptURL]; // 传输的是BASE64编码的字符串 /** BASE64 常用的编码方案，通常用于数据传输，以及加密算法的基础算法，传输过程中能够保证数据传输的稳定性 BASE64是可以编码和解码的 */ NSDictionary *requestContents = @&#123; @&quot;receipt-data&quot;: [receipt base64EncodedStringWithOptions:0] &#125;; NSError *error; // 转换为 JSON 格式 NSData *requestData = [NSJSONSerialization dataWithJSONObject:requestContents options:0 error:&amp;error]; // 不存在 if (!requestData) &#123; /* ... Handle error ... */ &#125; // 发送网络POST请求，对购买凭据进行验证 NSString *verifyUrlString; 测试环境 verifyUrlString = @&quot;https://sandbox.itunes.apple.com/verifyReceipt&quot;; 生产环境 verifyUrlString = @&quot;https://buy.itunes.apple.com/verifyReceipt&quot;; // 国内访问苹果服务器比较慢，timeoutInterval 需要长一点 NSMutableURLRequest *storeRequest = [NSMutableURLRequest requestWithURL:[[NSURL alloc] initWithString:verifyUrlString] cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:10.0f]; [storeRequest setHTTPMethod:@&quot;POST&quot;]; [storeRequest setHTTPBody:requestData]; // 在后台对列中提交验证请求，并获得官方的验证JSON结果 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [NSURLConnection sendAsynchronousRequest:storeRequest queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; if (connectionError) &#123; NSLog(@&quot;链接失败&quot;); &#125; else &#123; NSError *error; NSDictionary *jsonResponse = [NSJSONSerialization JSONObjectWithData:data options:0 error:&amp;error]; if (!jsonResponse) &#123; NSLog(@&quot;验证失败&quot;); &#125; // 比对 jsonResponse 中以下信息基本上可以保证数据安全 /* bundle_id application_version product_id transaction_id */ NSLog(@&quot;验证成功&quot;); &#125; &#125;]; &#125; 苹果官方文档刚接触内购如有不足之处请指教]]></content>
      <categories>
        <category>内购</category>
      </categories>
      <tags>
        <tag>内购</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac最新安装Ruby]]></title>
    <url>%2F2017%2F06%2F20%2FMac%E5%AE%89%E8%A3%85Ruby%2F</url>
    <content type="text"><![CDATA[安装CocoaPods第一步起因:重装系统后需要重新安装CocoaPods网上搜了下发现很多都过时了，已经不能用了。而且taobao Gems源已经停止服务，现在有ruby-china提供服PS：”$”开头表示需要在终端下执行 1.安装RVM1$ curl -L https://get.rvm.io | bash -s stable 期间可能需要输入密码(我安装时没有提示，密码就是开机密码输入时密码不会显示直接输入完成就可以)，等待一段时间将安装好(大概五六分钟)。 2.载入RVM环境若打开新终端窗口则不用执行1$ source ~/.rvm/scripts/rvm 3.检查RVM是否安装好1$ rvm -v 4.安装Ruby1&gt;列出已知的ruby版本1$ rvm list known 2&gt;选择2.0.0版本进行安装(其他版本也可以)等待下载(途中需要按回车确定安装路径、还要输入密码)、编译。完成之后Ruby、Ruby Gems就安装好了1$ rvm install 2.0.0 3&gt;查询已安装的ruby1$ rvm list 4&gt;卸载已安装的版本(若已经安装过ruby）1$ rvm remove [版本号] 4.设置Ruby版本1$ rvm 2.0.0 —default 检查是否安装好了1$ rvm -v 1$ gem -v 5.更换Ruby源我们需要来修改更换Ruby源，国内镜像源 taobao 源 已经停止维护了（由于国内被墙）所以要把源切换至ruby-china 1&gt;检测Ruby源1$ gem sources -l 检查结果：（ 如果电脑没安装过 CocoaPods，此时应该是默认 ruby 源 ）123huanghaipoMacBook-Pro:~ jijiucheng$ gem sources -l*** CURRENT SOURCES ***https://rubygems.org/ 2&gt;移除 ruby 源1$ gem sources --remove https://rubygems.org/ 3&gt;移除结果：12huanghaipoMacBook-Pro:local jijiucheng$ gem sources --remove https://rubygems.org/https://rubygems.org/ removed from sources 替换添加国内镜像源 ruby-china 源，因为上面已经提到国内镜像源 taobao 源 已经停止维护了，所以此处替换的是 ruby-china 源，且尽量确保只有一个 ruby-china 源1$ gem sources --add https://gems.ruby-china.org 4&gt;替换结果：12huanghaipoMacBook-Pro:local jijiucheng$ gem sources --add https://gems.ruby-china.orghttps://gems.ruby-china.org added to sources 5&gt;再次检查此时的 ruby 源：（ 已经变成了 ruby-china 源 ）123huanghaipoMacBook-Pro:local jijiucheng$ gem sources -l*** CURRENT SOURCES ***https://gems.ruby-china.org]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苹果IAP流程(2017)]]></title>
    <url>%2F2017%2F06%2F20%2F%E5%86%85%E8%B4%AD%2F</url>
    <content type="text"><![CDATA[什么是内购？只要在iPhone App上购买的不是实物产品(也就是虚拟产品如qq币.虎牙币.电子书……) 都需要走内购流程,苹果在里面抽走三成。使用内购需要走的流程。1,填写协议,税务和银行业务;2,填写用户和职能; 创建内购的项目 3,写代码,和后台配合4,添加项目内购测试账号;检验成果具体步骤：接下来的步骤特别繁琐，请做好准备。一.填写协议,税务和银行业务配置itunesconnect 1.请求合同 填写地址信息 阅读同意协议 2.填写联系方式 添加新的联系人 选中联系人 3.填写银行信息 添加银行卡 选择银行卡所在国家 填写银行CNAPS Code货币类型 CN 银行账号如果是对公的账号，需要填写公司的英文名称，如果没有的话拼音 4.填写税务信息U.S Tax Forms: 美国税务Australia Tax Forms：澳大利亚税务Canada Tax Forms: 加拿大税务第一个问题如下：询问你是否是美国居民，有没有美国伙伴关系或者美国公司，如果没有直接选择No。第二个问题如下：询问你有没有在美国的商业性活动，没有也直接选No ###然后填写你的税务信息，包括以下几点：Individual or Organization Name：个人或者组织名称Country of incorporation： 所在国家Type of Beneficial Owner：受益方式，独立开发者选个人Permanent Residence：居住地址Mailing address：邮寄地址Name of Person Making this Declaration：声明人Title：头衔 填写完这些信息后就可以提交了 5.等待审核,时间24小时左右。 二.创建内购项目选中你要添加内购项目的APP然后点击功能,点击+创建内购项目。 根据自己APP的需求选择类型 填写项目名称id (ps:应用在首次添加内购买项目时需要与新的应用版本一起提交审核。) 添加沙盒技术测试员用户职能&gt;沙箱技术测试员 注意事项:邮箱随便写但是格式要正确(test@163.com)，但是不能用已经是AppleID的邮箱App Store 地区不要乱选。虽然随便哪个地区都可以用来测试（还没上线之前app并没有地区之分），但是在沙盒测试的时候，弹出的购买提示框会根据当前AppleID(沙盒账号)的地区显示语言的。使用沙盒测试一定要用真机 (越狱的不行)沙盒账号不能直接登录AppleStore登录时会提示”不允许创建iTunes账户”进行沙盒测试时需要退出AppleStore的账号三.代码12345678910111213141516171819202122#import &lt;Foundation/Foundation.h&gt;#import &quot;WXApi.h&quot;typedef NS_ENUM(NSInteger , Payment) &#123; IAP6 = 6, IAP25 = 25, IAP60 = 60&#125;;@interface PayCenter : NSObjectsingleton_interface(PayCenter);- (void)startInit;- (void)payWithMoney:(NSInteger)money andType:(PayType)type dataDic:(NSDictionary *)dataDic;@property (nonatomic, strong) MBProgressHUD * hud;@property (nonatomic, copy) NSString * rechargeNumber;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#define kProductID_IAP6 @&quot;org.qqhl.nursning.6&quot;//6#import &quot;PayCenter.h&quot;#import &quot;PayHttpRequest.h&quot;//#import &quot;Order.h&quot;//#import &quot;DataSigner.h&quot;//#import &lt;AlipaySDK/AlipaySDK.h&gt;#import &lt;StoreKit/StoreKit.h&gt;@interface PayCenter()&lt;SKPaymentTransactionObserver,SKProductsRequestDelegate&gt;&#123; int buyType; NSInteger _money;&#125;@property (nonatomic, strong) NSMutableDictionary * dataDic;@end@implementation PayCentersingleton_implementation(PayCenter);- (void)startInit&#123; [WXApi registerApp:kWeChatShareAppKey withDescription:appDefaultTilte];&#125;- (void)payWithMoney:(NSInteger)money andType:(PayType)type dataDic:(NSDictionary *)dataDic&#123; _money = money; self.dataDic = [NSMutableDictionary dictionaryWithDictionary:dataDic]; switch (type) &#123; case PayTypeWX: [self payTypeWXPay]; break; case ApplePay:// [self payTypeAliPay]; [[SKPaymentQueue defaultQueue]addTransactionObserver:self]; if ([SKPaymentQueue canMakePayments]) &#123; HULog(@&quot;允许程序内付费购买&quot;); [self payTypeApplePay]; &#125;else &#123; HULog(@&quot;不允许程序内付费购买&quot;); UIAlertView *alerView = [[UIAlertView alloc] initWithTitle:@&quot;提示&quot; message:@&quot;您的手机没有打开程序内付费购买&quot; delegate:nil cancelButtonTitle:NSLocalizedString(@&quot;关闭&quot;,nil) otherButtonTitles:nil]; [alerView show]; &#125; break; default: break; &#125;&#125;- (void)payTypeApplePay&#123; NSLog(@&quot;---------请求对应的产品信息------------&quot;); NSArray *product = nil; switch (_money) &#123; case IAP6: &#123; product=[[NSArray alloc] initWithObjects:kProductID_IAP6,nil]; NSLog(@&quot;---------IAP6------------&quot;); &#125; break; case IAP25: &#123; NSLog(@&quot;---------IAP25------------&quot;); &#125; break; case IAP60: &#123; NSLog(@&quot;---------IAP60------------&quot;); &#125; break; default: break; &#125; NSSet *nsSet = [NSSet setWithArray:product]; SKProductsRequest *request = [[SKProductsRequest alloc]initWithProductIdentifiers:nsSet]; request.delegate = self; [request start];&#125;#pragma mark - SKProductsRequestDelegate代理//返回的在苹果服务器请求的产品信息- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response&#123; HULog(@&quot;收到产品信息&quot;); NSArray *myProduct = response.products; HULog(@&quot;产品id %@&quot;,response.invalidProductIdentifiers); NSLog(@&quot;产品付费数量%d&quot;,(int)[myProduct count]);//populate UI for (SKProduct *product in myProduct) &#123; NSLog(@&quot;product info&quot;); NSLog(@&quot;SKProduct 描述信息%@&quot;, [product description]); NSLog(@&quot;产品标题 %@&quot; , product.localizedTitle); NSLog(@&quot;产品描述信息: %@&quot; , product.localizedDescription); NSLog(@&quot;价格: %@&quot; , product.price); NSLog(@&quot;Product id: %@&quot; , product.productIdentifier); &#125; SKPayment *payment = nil; switch (_money) &#123; case IAP6: &#123; payment = [SKPayment paymentWithProductIdentifier:kProductID_IAP6]; &#125; break; case IAP25:&#123; &#125; default: break; &#125; NSLog(@&quot;发起购买请求&quot;); [[SKPaymentQueue defaultQueue]addPayment:payment]; &#125;//实现监听方法- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray&lt;SKPaymentTransaction *&gt; *)transactions&#123; NSLog(@&quot;调用了几次这个方法？&quot;); SKPaymentTransaction *transaction = transactions.lastObject; switch (transaction.transactionState) &#123; case SKPaymentTransactionStatePurchased: &#123; NSLog(@&quot;购买完成,向自己的服务器验证 ---- %@&quot;, transaction.payment.applicationUsername); NSData *data = [NSData dataWithContentsOfFile:[[[NSBundle mainBundle] appStoreReceiptURL] path]]; NSString *receipt = [data base64EncodedStringWithOptions:0];// [self buySuccessWithReceipt:receipt transaction:transaction]; &#125; break; case SKPaymentTransactionStateFailed: &#123; NSLog(@&quot;交易失败&quot;); [[SKPaymentQueue defaultQueue] finishTransaction:transaction]; &#125; break; case SKPaymentTransactionStateRestored: &#123; NSLog(@&quot;已经购买过该商品&quot;); [[SKPaymentQueue defaultQueue] finishTransaction:transaction]; &#125; break; case SKPaymentTransactionStatePurchasing: &#123; NSLog(@&quot;商品添加进列表&quot;); &#125; break; default: &#123; NSLog(@&quot;这是什么情况啊？&quot;); &#125; break; &#125;&#125;@end 购买成功后需要跟服务器交互验证交易是否成功123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 验证凭据，获取到苹果返回的交易凭据 // appStoreReceiptURL iOS7.0增加的，购买交易完成后，会将凭据存放在该地址 NSURL *receiptURL = [[NSBundle mainBundle] appStoreReceiptURL]; // 从沙盒中获取到购买凭据 NSData *receipt = [NSData dataWithContentsOfURL:receiptURL]; // 传输的是BASE64编码的字符串 /** BASE64 常用的编码方案，通常用于数据传输，以及加密算法的基础算法，传输过程中能够保证数据传输的稳定性 BASE64是可以编码和解码的 */ NSDictionary *requestContents = @&#123; @&quot;receipt-data&quot;: [receipt base64EncodedStringWithOptions:0] &#125;; NSError *error; // 转换为 JSON 格式 NSData *requestData = [NSJSONSerialization dataWithJSONObject:requestContents options:0 error:&amp;error]; // 不存在 if (!requestData) &#123; /* ... Handle error ... */ &#125; // 发送网络POST请求，对购买凭据进行验证 NSString *verifyUrlString; 测试环境 verifyUrlString = @&quot;https://sandbox.itunes.apple.com/verifyReceipt&quot;; 生产环境 verifyUrlString = @&quot;https://buy.itunes.apple.com/verifyReceipt&quot;; // 国内访问苹果服务器比较慢，timeoutInterval 需要长一点 NSMutableURLRequest *storeRequest = [NSMutableURLRequest requestWithURL:[[NSURL alloc] initWithString:verifyUrlString] cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:10.0f]; [storeRequest setHTTPMethod:@&quot;POST&quot;]; [storeRequest setHTTPBody:requestData]; // 在后台对列中提交验证请求，并获得官方的验证JSON结果 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [NSURLConnection sendAsynchronousRequest:storeRequest queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; if (connectionError) &#123; NSLog(@&quot;链接失败&quot;); &#125; else &#123; NSError *error; NSDictionary *jsonResponse = [NSJSONSerialization JSONObjectWithData:data options:0 error:&amp;error]; if (!jsonResponse) &#123; NSLog(@&quot;验证失败&quot;); &#125; // 比对 jsonResponse 中以下信息基本上可以保证数据安全 /* bundle_id application_version product_id transaction_id */ NSLog(@&quot;验证成功&quot;); &#125; &#125;]; &#125; 苹果官方文档]]></content>
      <categories>
        <category>苹果内购</category>
      </categories>
      <tags>
        <tag>内购</tag>
        <tag>IAP</tag>
      </tags>
  </entry>
</search>
