<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[苹果IAP流程(2017)]]></title>
    <url>%2F2017%2F06%2F20%2F%E5%86%85%E8%B4%AD%2F</url>
    <content type="text"><![CDATA[什么是内购？只要在iPhone App上购买的不是实物产品(也就是虚拟产品如qq币.虎牙币.电子书……) 都需要走内购流程,苹果在里面抽走三成。使用内购需要走的流程。1,填写协议,税务和银行业务;2,填写用户和职能; 创建内购的项目3,写代码,和后台配合4,添加项目内购测试账号;检验成果具体步骤：接下来的步骤特别繁琐，请做好准备。一.填写协议,税务和银行业务配置itunesconnect 1.请求合同 填写地址信息 阅读同意协议 2.填写联系方式 添加新的联系人 选中联系人 3.填写银行信息 添加银行卡 选择银行卡所在国家 填写银行CNAPS Code货币类型 CN 银行账号如果是对公的账号，需要填写公司的英文名称，如果没有的话拼音 4.填写税务信息U.S Tax Forms: 美国税务Australia Tax Forms：澳大利亚税务Canada Tax Forms: 加拿大税务第一个问题如下：询问你是否是美国居民，有没有美国伙伴关系或者美国公司，如果没有直接选择No。第二个问题如下：询问你有没有在美国的商业性活动，没有也直接选No ###然后填写你的税务信息，包括以下几点：Individual or Organization Name：个人或者组织名称Country of incorporation： 所在国家Type of Beneficial Owner：受益方式，独立开发者选个人Permanent Residence：居住地址Mailing address：邮寄地址Name of Person Making this Declaration：声明人Title：头衔 填写完这些信息后就可以提交了 5.等待审核,时间24小时左右。 二.创建内购项目选中你要添加内购项目的APP然后点击功能,点击+创建内购项目。 根据自己APP的需求选择类型 填写项目名称id (ps:应用在首次添加内购买项目时需要与新的应用版本一起提交审核。) 添加沙盒技术测试员用户职能&gt;沙箱技术测试员 注意事项:邮箱随便写但是格式要正确(test@163.com)，但是不能用已经是AppleID的邮箱App Store 地区不要乱选。虽然随便哪个地区都可以用来测试（还没上线之前app并没有地区之分），但是在沙盒测试的时候，弹出的购买提示框会根据当前AppleID(沙盒账号)的地区显示语言的。使用沙盒测试一定要用真机 (越狱的不行)沙盒账号不能直接登录AppleStore登录时会提示”不允许创建iTunes账户”进行沙盒测试时需要退出AppleStore的账号三.代码12345678910111213141516171819202122#import &lt;Foundation/Foundation.h&gt;#import &quot;WXApi.h&quot;typedef NS_ENUM(NSInteger , Payment) &#123; IAP6 = 6, IAP25 = 25, IAP60 = 60&#125;;@interface PayCenter : NSObjectsingleton_interface(PayCenter);- (void)startInit;- (void)payWithMoney:(NSInteger)money andType:(PayType)type dataDic:(NSDictionary *)dataDic;@property (nonatomic, strong) MBProgressHUD * hud;@property (nonatomic, copy) NSString * rechargeNumber;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#define kProductID_IAP6 @&quot;org.qqhl.nursning.6&quot;//6#import &quot;PayCenter.h&quot;#import &quot;PayHttpRequest.h&quot;//#import &quot;Order.h&quot;//#import &quot;DataSigner.h&quot;//#import &lt;AlipaySDK/AlipaySDK.h&gt;#import &lt;StoreKit/StoreKit.h&gt;@interface PayCenter()&lt;SKPaymentTransactionObserver,SKProductsRequestDelegate&gt;&#123; int buyType; NSInteger _money;&#125;@property (nonatomic, strong) NSMutableDictionary * dataDic;@end@implementation PayCentersingleton_implementation(PayCenter);- (void)startInit&#123; [WXApi registerApp:kWeChatShareAppKey withDescription:appDefaultTilte];&#125;- (void)payWithMoney:(NSInteger)money andType:(PayType)type dataDic:(NSDictionary *)dataDic&#123; _money = money; self.dataDic = [NSMutableDictionary dictionaryWithDictionary:dataDic]; switch (type) &#123; case PayTypeWX: [self payTypeWXPay]; break; case ApplePay:// [self payTypeAliPay]; [[SKPaymentQueue defaultQueue]addTransactionObserver:self]; if ([SKPaymentQueue canMakePayments]) &#123; HULog(@&quot;允许程序内付费购买&quot;); [self payTypeApplePay]; &#125;else &#123; HULog(@&quot;不允许程序内付费购买&quot;); UIAlertView *alerView = [[UIAlertView alloc] initWithTitle:@&quot;提示&quot; message:@&quot;您的手机没有打开程序内付费购买&quot; delegate:nil cancelButtonTitle:NSLocalizedString(@&quot;关闭&quot;,nil) otherButtonTitles:nil]; [alerView show]; &#125; break; default: break; &#125;&#125;- (void)payTypeApplePay&#123; NSLog(@&quot;---------请求对应的产品信息------------&quot;); NSArray *product = nil; switch (_money) &#123; case IAP6: &#123; product=[[NSArray alloc] initWithObjects:kProductID_IAP6,nil]; NSLog(@&quot;---------IAP6------------&quot;); &#125; break; case IAP25: &#123; NSLog(@&quot;---------IAP25------------&quot;); &#125; break; case IAP60: &#123; NSLog(@&quot;---------IAP60------------&quot;); &#125; break; default: break; &#125; NSSet *nsSet = [NSSet setWithArray:product]; SKProductsRequest *request = [[SKProductsRequest alloc]initWithProductIdentifiers:nsSet]; request.delegate = self; [request start];&#125;#pragma mark - SKProductsRequestDelegate代理//返回的在苹果服务器请求的产品信息- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response&#123; HULog(@&quot;收到产品信息&quot;); NSArray *myProduct = response.products; HULog(@&quot;产品id %@&quot;,response.invalidProductIdentifiers); NSLog(@&quot;产品付费数量%d&quot;,(int)[myProduct count]);//populate UI for (SKProduct *product in myProduct) &#123; NSLog(@&quot;product info&quot;); NSLog(@&quot;SKProduct 描述信息%@&quot;, [product description]); NSLog(@&quot;产品标题 %@&quot; , product.localizedTitle); NSLog(@&quot;产品描述信息: %@&quot; , product.localizedDescription); NSLog(@&quot;价格: %@&quot; , product.price); NSLog(@&quot;Product id: %@&quot; , product.productIdentifier); &#125; SKPayment *payment = nil; switch (_money) &#123; case IAP6: &#123; payment = [SKPayment paymentWithProductIdentifier:kProductID_IAP6]; &#125; break; case IAP25:&#123; &#125; default: break; &#125; NSLog(@&quot;发起购买请求&quot;); [[SKPaymentQueue defaultQueue]addPayment:payment]; &#125;//实现监听方法- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray&lt;SKPaymentTransaction *&gt; *)transactions&#123; NSLog(@&quot;调用了几次这个方法？&quot;); SKPaymentTransaction *transaction = transactions.lastObject; switch (transaction.transactionState) &#123; case SKPaymentTransactionStatePurchased: &#123; NSLog(@&quot;购买完成,向自己的服务器验证 ---- %@&quot;, transaction.payment.applicationUsername); NSData *data = [NSData dataWithContentsOfFile:[[[NSBundle mainBundle] appStoreReceiptURL] path]]; NSString *receipt = [data base64EncodedStringWithOptions:0];// [self buySuccessWithReceipt:receipt transaction:transaction]; &#125; break; case SKPaymentTransactionStateFailed: &#123; NSLog(@&quot;交易失败&quot;); [[SKPaymentQueue defaultQueue] finishTransaction:transaction]; &#125; break; case SKPaymentTransactionStateRestored: &#123; NSLog(@&quot;已经购买过该商品&quot;); [[SKPaymentQueue defaultQueue] finishTransaction:transaction]; &#125; break; case SKPaymentTransactionStatePurchasing: &#123; NSLog(@&quot;商品添加进列表&quot;); &#125; break; default: &#123; NSLog(@&quot;这是什么情况啊？&quot;); &#125; break; &#125;&#125;@end 购买成功后需要跟服务器交互验证交易是否成功123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 验证凭据，获取到苹果返回的交易凭据 // appStoreReceiptURL iOS7.0增加的，购买交易完成后，会将凭据存放在该地址 NSURL *receiptURL = [[NSBundle mainBundle] appStoreReceiptURL]; // 从沙盒中获取到购买凭据 NSData *receipt = [NSData dataWithContentsOfURL:receiptURL]; // 传输的是BASE64编码的字符串 /** BASE64 常用的编码方案，通常用于数据传输，以及加密算法的基础算法，传输过程中能够保证数据传输的稳定性 BASE64是可以编码和解码的 */ NSDictionary *requestContents = @&#123; @&quot;receipt-data&quot;: [receipt base64EncodedStringWithOptions:0] &#125;; NSError *error; // 转换为 JSON 格式 NSData *requestData = [NSJSONSerialization dataWithJSONObject:requestContents options:0 error:&amp;error]; // 不存在 if (!requestData) &#123; /* ... Handle error ... */ &#125; // 发送网络POST请求，对购买凭据进行验证 NSString *verifyUrlString; 测试环境 verifyUrlString = @&quot;https://sandbox.itunes.apple.com/verifyReceipt&quot;; 生产环境 verifyUrlString = @&quot;https://buy.itunes.apple.com/verifyReceipt&quot;; // 国内访问苹果服务器比较慢，timeoutInterval 需要长一点 NSMutableURLRequest *storeRequest = [NSMutableURLRequest requestWithURL:[[NSURL alloc] initWithString:verifyUrlString] cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:10.0f]; [storeRequest setHTTPMethod:@&quot;POST&quot;]; [storeRequest setHTTPBody:requestData]; // 在后台对列中提交验证请求，并获得官方的验证JSON结果 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [NSURLConnection sendAsynchronousRequest:storeRequest queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; if (connectionError) &#123; NSLog(@&quot;链接失败&quot;); &#125; else &#123; NSError *error; NSDictionary *jsonResponse = [NSJSONSerialization JSONObjectWithData:data options:0 error:&amp;error]; if (!jsonResponse) &#123; NSLog(@&quot;验证失败&quot;); &#125; // 比对 jsonResponse 中以下信息基本上可以保证数据安全 /* bundle_id application_version product_id transaction_id */ NSLog(@&quot;验证成功&quot;); &#125; &#125;]; &#125; 苹果官方文档]]></content>
      <categories>
        <category>苹果内购</category>
      </categories>
      <tags>
        <tag>IAP</tag>
        <tag>内购</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac最新安装Ruby]]></title>
    <url>%2F2017%2F06%2F20%2FMac%E5%AE%89%E8%A3%85Ruby%2F</url>
    <content type="text"><![CDATA[安装CocoaPods第一步起因:重装系统后需要重新安装CocoaPods网上搜了下发现很多都过时了，已经不能用了。而且taobao Gems源已经停止服务，现在有ruby-china提供服PS：”$”开头表示需要在终端下执行 1.安装RVM1$ curl -L https://get.rvm.io | bash -s stable 期间可能需要输入密码(我安装时没有提示，密码就是开机密码输入时密码不会显示直接输入完成就可以)，等待一段时间将安装好(大概五六分钟)。 2.载入RVM环境若打开新终端窗口则不用执行1$ source ~/.rvm/scripts/rvm 3.检查RVM是否安装好1$ rvm -v 4.安装Ruby1&gt;列出已知的ruby版本1$ rvm list known 2&gt;选择2.0.0版本进行安装(其他版本也可以)等待下载(途中需要按回车确定安装路径、还要输入密码)、编译。完成之后Ruby、Ruby Gems就安装好了1$ rvm install 2.0.0 3&gt;查询已安装的ruby1$ rvm list 4&gt;卸载已安装的版本(若已经安装过ruby）1$ rvm remove [版本号] 4.设置Ruby版本1$ rvm 2.0.0 —default 检查是否安装好了1$ rvm -v 1$ gem -v 5.更换Ruby源我们需要来修改更换Ruby源，国内镜像源 taobao 源 已经停止维护了（由于国内被墙）所以要把源切换至ruby-china 1&gt;检测Ruby源1$ gem sources -l 检查结果：（ 如果电脑没安装过 CocoaPods，此时应该是默认 ruby 源 ）123huanghaipoMacBook-Pro:~ jijiucheng$ gem sources -l*** CURRENT SOURCES ***https://rubygems.org/ 2&gt;移除 ruby 源1$ gem sources --remove https://rubygems.org/ 3&gt;移除结果：12huanghaipoMacBook-Pro:local jijiucheng$ gem sources --remove https://rubygems.org/https://rubygems.org/ removed from sources 替换添加国内镜像源 ruby-china 源，因为上面已经提到国内镜像源 taobao 源 已经停止维护了，所以此处替换的是 ruby-china 源，且尽量确保只有一个 ruby-china 源1$ gem sources --add https://gems.ruby-china.org 4&gt;替换结果：12huanghaipoMacBook-Pro:local jijiucheng$ gem sources --add https://gems.ruby-china.orghttps://gems.ruby-china.org added to sources 5&gt;再次检查此时的 ruby 源：（ 已经变成了 ruby-china 源 ）123huanghaipoMacBook-Pro:local jijiucheng$ gem sources -l*** CURRENT SOURCES ***https://gems.ruby-china.org]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
</search>
