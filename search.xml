<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[史上最快用GitHub、Hexo搭建个人博客]]></title>
    <url>%2F2019%2F04%2F24%2F%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BF%AB%E7%94%A8GitHub%E3%80%81Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一. 准备工作 电脑一台(本文是基于Mac) 安装Git 安装Node.js GitHub账号一枚 如果读者电脑上已经装了git、Node、并且有GitHub账号，那么搭建个人博客绝对不超过抽一支烟的时间。 二. 安装git1. 在 Mac 上安装 Git，官方给了有两种方式。最容易的当属使用图形化的 Git 安装工具，界面如图，下载地址在下：Git GUI下载地址 2. 另一种是通过 MacPorts (http://www.macports.org) 安装。如果已经装好了 MacPorts，用下面的命令安装 Git：1$ sudo port install git-core +svn +doc +bash_completion +gitweb 译注：还有一种是使用 homebrew（https://github.com/mxcl/homebrew）：brew install git。 安装git官网教程 三. 安装Nodejs安装Nodejs也有两种方式GUI和终端命令 1. GUI下载地址Nodejs安装包下载地址 2. 终端执行命令先安装nvm，这是Nodejs版本管理器，可以轻松切换Nodejs版本。 curl方式安装nvm. 1$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash 下面是nvm部分输出，重点在最后，只有执行最后几条命令nvm才算安装完成。12345678910111213 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 11329 100 11329 0 0 4130 0 0:00:02 0:00:02 --:--:-- 4130=&gt; Downloading nvm from git to &apos;/Users/huanghaipo/.nvm&apos;=&gt; Initialized empty Git repository in /Users/huanghaipo/.nvm/.git/=&gt; Appending nvm source string to /Users/huanghaipo/.bashrc=&gt; bash_completion source string already in /Users/huanghaipo/.bashrc=&gt; Close and reopen your terminal to start using nvm or run the following to use it now://这里是执行命令export NVM_DIR=&quot;/Users/leon/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 根据提示执行命令load nvm,最后几条命令每个人的都不同。 123$ export NVM_DIR=&quot;/Users/leon/.nvm&quot;$ [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;$ nvm 使用nvm安装node1$ nvm install node 验证node及npm版本，如果有下方输出证明安装成功。 1234$ node -vv11.14.0$ npm -v6.7.0 四. 创建Github域名和仓库1. 注册GitHub账号注册Github账号，Username很重要，域名将是账号名加.github.io，username.github.io。 2. 创建仓库注册账号后我们需要创建一个存储网站数据的仓库，点击首页右上角加号，点击New repository按钮创建仓库。 Respository name 中的username.github.io 的username 一定与前面的Owner 一致，记住username后面会用到。 到此准备工作已经全部完成了。接下来就是安装hexo了。 五. 安装Hexo以上工作全部完成我们就可以安装Hexo了。一个崭新的博客将要出现。 1. 执行下方命令安装hexo1$ sudo npm install hexo-cli -g 安装完成后我们就可以初始化博客了，如果想要把文件放到某个目录下先cd到指定目录下在执行下方命令，如果没有指定目录默认是的你的个人主目录下。 12//username就是你刚才仓库的名称$ hexo init username.github.io 2. 配置博客设置初始化博客后我们需要修改配置文件已达到想要的效果如名字、主题等。 主题安装 为了美观我们安装一个火热的主题。先cd到刚才生成的目录下执行下方命令。12$ cd username.github.io$ git clone https://github.com/iissnan/hexo-theme-next themes/next 基础设置 找到_config.yml文件username.github.io/_config.yml修改下方基础配置保存修改。 注意_config.yml中配置项的冒号后面要用空格隔开，再跟内容否则启动服务时会报错。1234567title: huanghaipo //博客的名字author: huanghaipo //你的名字language: zh-Hans //语言 中文theme: next //刚刚安装的主题名称deploy:type: git //Github发布repo: https://github.com/username/username.github.io.git // 刚创建的Github仓库链接也可以选择ssh 3. 编写文章前期工作已近基本完成，接下来我们可以写文章了。发布就可以得到一枚个人博客，首先新建一个.md文件，命名为firstEssay.md，写入下方内容。放到username.github.io/source/_posts文件下。1234 --- title: 我的第一篇文章 ---**我的第一篇文章** 或者cd到你的博客文件夹执行下方命令行会得到一个md文件。 1hexo new post &quot;这是测试新建md文档&quot; //名字随便取 执行完以上命令，得到md文件，内容如下。12345---title: 这是测试新建md文档date: 2019-04-24 10:20:50 tags: //博客标签--- 4. 启动测试启动服务，直接浏览器中输入https://localhost:4000或者直接点击我 访问。1$ hexo s 5. 安装hexo-deployer-git自动部署发布工具1$ npm install hexo-deployer-git --save 6.发布以上步骤都完成后，我们就可以把生成的静态网页文件发布到Github上。以后直接通过连接就可以访问这个博客了。 12345$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d命令解释hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g //生成缓存和静态文件hexo d //重新部署到服务器 如果你使用的是HTTP可能会让你输入账号密码，输入正确后，稍等片刻，就会吧文件上传到Github上，然后直接访问刚才username.github.io就能看到自己的博客了。如果有新的文章只需要放到username.github.io/source/_posts下然后执行上面的命令就OK了。 最终效果 优化如果觉得这个主题不好看请或者想要更新博客更方便、更美观，请看这里。 hexo主题主题配置基础配置hexo插件 hexo常用命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 踩坑记录: 终端报错:1FATAL can not read a block mapping entry; a multiline key may not be an implicit key at line 70, column 1: ... 解决办法：_config.yml中配置项的冒号后面要用空格隔开，再跟内容 1出现 error deployer not found:git 或者 error deployer not found:github 的错误 解决办法：执行 npm install hexo-deployer-git –save 1中文乱码问题 解决办法：将文件的内容编码改为UTF8格式 1&apos;hexo sever&apos;能够成功运行，但是localhost:4000无法访问 解决办法：执行hexo s -p 5000，改用其他端口启动]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>Hexo</tag>
        <tag>GitHub Page</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac最新安装Ruby]]></title>
    <url>%2F2017%2F06%2F20%2FMac%E5%AE%89%E8%A3%85Ruby%2F</url>
    <content type="text"><![CDATA[安装CocoaPods第一步起因:重装系统后需要重新安装CocoaPods网上搜了下发现很多都过时了，已经不能用了。而且taobao Gems源已经停止服务，现在有ruby-china提供服PS：”$”开头表示需要在终端下执行 1.安装RVM1$ curl -L https://get.rvm.io | bash -s stable 期间可能需要输入密码(我安装时没有提示，密码就是开机密码输入时密码不会显示直接输入完成就可以)，等待一段时间将安装好(大概五六分钟)。 2.载入RVM环境若打开新终端窗口则不用执行1$ source ~/.rvm/scripts/rvm 3.检查RVM是否安装好1$ rvm -v 4.安装Ruby1&gt;列出已知的ruby版本1$ rvm list known 2&gt;选择2.0.0版本进行安装(其他版本也可以)等待下载(途中需要按回车确定安装路径、还要输入密码)、编译。完成之后Ruby、Ruby Gems就安装好了1$ rvm install 2.0.0 3&gt;查询已安装的ruby1$ rvm list 4&gt;卸载已安装的版本(若已经安装过ruby）1$ rvm remove [版本号] 4.设置Ruby版本1$ rvm 2.0.0 —default 检查是否安装好了1$ rvm -v 1$ gem -v 5.更换Ruby源我们需要来修改更换Ruby源，国内镜像源 taobao 源 已经停止维护了（由于国内被墙）所以要把源切换至ruby-china 1&gt;检测Ruby源1$ gem sources -l 检查结果：（ 如果电脑没安装过 CocoaPods，此时应该是默认 ruby 源 ）123huanghaipoMacBook-Pro:~ jijiucheng$ gem sources -l*** CURRENT SOURCES ***https://rubygems.org/ 2&gt;移除 ruby 源1$ gem sources --remove https://rubygems.org/ 3&gt;移除结果：12huanghaipoMacBook-Pro:local jijiucheng$ gem sources --remove https://rubygems.org/https://rubygems.org/ removed from sources 替换添加国内镜像源 ruby-china 源，因为上面已经提到国内镜像源 taobao 源 已经停止维护了，所以此处替换的是 ruby-china 源，且尽量确保只有一个 ruby-china 源1$ gem sources --add https://gems.ruby-china.org 4&gt;替换结果：12huanghaipoMacBook-Pro:local jijiucheng$ gem sources --add https://gems.ruby-china.orghttps://gems.ruby-china.org added to sources 5&gt;再次检查此时的 ruby 源：（ 已经变成了 ruby-china 源 ）123huanghaipoMacBook-Pro:local jijiucheng$ gem sources -l*** CURRENT SOURCES ***https://gems.ruby-china.org]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苹果IAP流程(2017)]]></title>
    <url>%2F2017%2F06%2F20%2F%E5%86%85%E8%B4%AD%2F</url>
    <content type="text"><![CDATA[什么是内购？只要在iPhone App上购买的不是实物产品(也就是虚拟产品如qq币.虎牙币.电子书……) 都需要走内购流程,苹果在里面抽走三成。使用内购需要走的流程。1,填写协议,税务和银行业务;2,填写用户和职能; 创建内购的项目 3,写代码,和后台配合4,添加项目内购测试账号;检验成果具体步骤：接下来的步骤特别繁琐，请做好准备。一.填写协议,税务和银行业务配置itunesconnect 1.请求合同 填写地址信息 阅读同意协议 2.填写联系方式 添加新的联系人 选中联系人 3.填写银行信息 添加银行卡 选择银行卡所在国家 填写银行CNAPS Code货币类型 CN 银行账号如果是对公的账号，需要填写公司的英文名称，如果没有的话拼音 4.填写税务信息U.S Tax Forms: 美国税务Australia Tax Forms：澳大利亚税务Canada Tax Forms: 加拿大税务第一个问题如下：询问你是否是美国居民，有没有美国伙伴关系或者美国公司，如果没有直接选择No。第二个问题如下：询问你有没有在美国的商业性活动，没有也直接选No ###然后填写你的税务信息，包括以下几点：Individual or Organization Name：个人或者组织名称Country of incorporation： 所在国家Type of Beneficial Owner：受益方式，独立开发者选个人Permanent Residence：居住地址Mailing address：邮寄地址Name of Person Making this Declaration：声明人Title：头衔 填写完这些信息后就可以提交了 5.等待审核,时间24小时左右。 二.创建内购项目选中你要添加内购项目的APP然后点击功能,点击+创建内购项目。 根据自己APP的需求选择类型 填写项目名称id (ps:应用在首次添加内购买项目时需要与新的应用版本一起提交审核。) 添加沙盒技术测试员用户职能&gt;沙箱技术测试员 注意事项:邮箱随便写但是格式要正确(test@163.com)，但是不能用已经是AppleID的邮箱App Store 地区不要乱选。虽然随便哪个地区都可以用来测试（还没上线之前app并没有地区之分），但是在沙盒测试的时候，弹出的购买提示框会根据当前AppleID(沙盒账号)的地区显示语言的。使用沙盒测试一定要用真机 (越狱的不行)沙盒账号不能直接登录AppleStore登录时会提示”不允许创建iTunes账户”进行沙盒测试时需要退出AppleStore的账号三.代码12345678910111213141516171819202122#import &lt;Foundation/Foundation.h&gt;#import &quot;WXApi.h&quot;typedef NS_ENUM(NSInteger , Payment) &#123; IAP6 = 6, IAP25 = 25, IAP60 = 60&#125;;@interface PayCenter : NSObjectsingleton_interface(PayCenter);- (void)startInit;- (void)payWithMoney:(NSInteger)money andType:(PayType)type dataDic:(NSDictionary *)dataDic;@property (nonatomic, strong) MBProgressHUD * hud;@property (nonatomic, copy) NSString * rechargeNumber;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#define kProductID_IAP6 @&quot;org.qqhl.nursning.6&quot;//6#import &quot;PayCenter.h&quot;#import &quot;PayHttpRequest.h&quot;//#import &quot;Order.h&quot;//#import &quot;DataSigner.h&quot;//#import &lt;AlipaySDK/AlipaySDK.h&gt;#import &lt;StoreKit/StoreKit.h&gt;@interface PayCenter()&lt;SKPaymentTransactionObserver,SKProductsRequestDelegate&gt;&#123; int buyType; NSInteger _money;&#125;@property (nonatomic, strong) NSMutableDictionary * dataDic;@end@implementation PayCentersingleton_implementation(PayCenter);- (void)startInit&#123; [WXApi registerApp:kWeChatShareAppKey withDescription:appDefaultTilte];&#125;- (void)payWithMoney:(NSInteger)money andType:(PayType)type dataDic:(NSDictionary *)dataDic&#123; _money = money; self.dataDic = [NSMutableDictionary dictionaryWithDictionary:dataDic]; switch (type) &#123; case PayTypeWX: [self payTypeWXPay]; break; case ApplePay:// [self payTypeAliPay]; [[SKPaymentQueue defaultQueue]addTransactionObserver:self]; if ([SKPaymentQueue canMakePayments]) &#123; HULog(@&quot;允许程序内付费购买&quot;); [self payTypeApplePay]; &#125;else &#123; HULog(@&quot;不允许程序内付费购买&quot;); UIAlertView *alerView = [[UIAlertView alloc] initWithTitle:@&quot;提示&quot; message:@&quot;您的手机没有打开程序内付费购买&quot; delegate:nil cancelButtonTitle:NSLocalizedString(@&quot;关闭&quot;,nil) otherButtonTitles:nil]; [alerView show]; &#125; break; default: break; &#125;&#125;- (void)payTypeApplePay&#123; NSLog(@&quot;---------请求对应的产品信息------------&quot;); NSArray *product = nil; switch (_money) &#123; case IAP6: &#123; product=[[NSArray alloc] initWithObjects:kProductID_IAP6,nil]; NSLog(@&quot;---------IAP6------------&quot;); &#125; break; case IAP25: &#123; NSLog(@&quot;---------IAP25------------&quot;); &#125; break; case IAP60: &#123; NSLog(@&quot;---------IAP60------------&quot;); &#125; break; default: break; &#125; NSSet *nsSet = [NSSet setWithArray:product]; SKProductsRequest *request = [[SKProductsRequest alloc]initWithProductIdentifiers:nsSet]; request.delegate = self; [request start];&#125;#pragma mark - SKProductsRequestDelegate代理//返回的在苹果服务器请求的产品信息- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response&#123; HULog(@&quot;收到产品信息&quot;); NSArray *myProduct = response.products; HULog(@&quot;产品id %@&quot;,response.invalidProductIdentifiers); NSLog(@&quot;产品付费数量%d&quot;,(int)[myProduct count]);//populate UI for (SKProduct *product in myProduct) &#123; NSLog(@&quot;product info&quot;); NSLog(@&quot;SKProduct 描述信息%@&quot;, [product description]); NSLog(@&quot;产品标题 %@&quot; , product.localizedTitle); NSLog(@&quot;产品描述信息: %@&quot; , product.localizedDescription); NSLog(@&quot;价格: %@&quot; , product.price); NSLog(@&quot;Product id: %@&quot; , product.productIdentifier); &#125; SKPayment *payment = nil; switch (_money) &#123; case IAP6: &#123; payment = [SKPayment paymentWithProductIdentifier:kProductID_IAP6]; &#125; break; case IAP25:&#123; &#125; default: break; &#125; NSLog(@&quot;发起购买请求&quot;); [[SKPaymentQueue defaultQueue]addPayment:payment]; &#125;//实现监听方法- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray&lt;SKPaymentTransaction *&gt; *)transactions&#123; NSLog(@&quot;调用了几次这个方法？&quot;); SKPaymentTransaction *transaction = transactions.lastObject; switch (transaction.transactionState) &#123; case SKPaymentTransactionStatePurchased: &#123; NSLog(@&quot;购买完成,向自己的服务器验证 ---- %@&quot;, transaction.payment.applicationUsername); NSData *data = [NSData dataWithContentsOfFile:[[[NSBundle mainBundle] appStoreReceiptURL] path]]; NSString *receipt = [data base64EncodedStringWithOptions:0];// [self buySuccessWithReceipt:receipt transaction:transaction]; &#125; break; case SKPaymentTransactionStateFailed: &#123; NSLog(@&quot;交易失败&quot;); [[SKPaymentQueue defaultQueue] finishTransaction:transaction]; &#125; break; case SKPaymentTransactionStateRestored: &#123; NSLog(@&quot;已经购买过该商品&quot;); [[SKPaymentQueue defaultQueue] finishTransaction:transaction]; &#125; break; case SKPaymentTransactionStatePurchasing: &#123; NSLog(@&quot;商品添加进列表&quot;); &#125; break; default: &#123; NSLog(@&quot;这是什么情况啊？&quot;); &#125; break; &#125;&#125;@end 购买成功后需要跟服务器交互验证交易是否成功123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 验证凭据，获取到苹果返回的交易凭据 // appStoreReceiptURL iOS7.0增加的，购买交易完成后，会将凭据存放在该地址 NSURL *receiptURL = [[NSBundle mainBundle] appStoreReceiptURL]; // 从沙盒中获取到购买凭据 NSData *receipt = [NSData dataWithContentsOfURL:receiptURL]; // 传输的是BASE64编码的字符串 /** BASE64 常用的编码方案，通常用于数据传输，以及加密算法的基础算法，传输过程中能够保证数据传输的稳定性 BASE64是可以编码和解码的 */ NSDictionary *requestContents = @&#123; @&quot;receipt-data&quot;: [receipt base64EncodedStringWithOptions:0] &#125;; NSError *error; // 转换为 JSON 格式 NSData *requestData = [NSJSONSerialization dataWithJSONObject:requestContents options:0 error:&amp;error]; // 不存在 if (!requestData) &#123; /* ... Handle error ... */ &#125; // 发送网络POST请求，对购买凭据进行验证 NSString *verifyUrlString; 测试环境 verifyUrlString = @&quot;https://sandbox.itunes.apple.com/verifyReceipt&quot;; 生产环境 verifyUrlString = @&quot;https://buy.itunes.apple.com/verifyReceipt&quot;; // 国内访问苹果服务器比较慢，timeoutInterval 需要长一点 NSMutableURLRequest *storeRequest = [NSMutableURLRequest requestWithURL:[[NSURL alloc] initWithString:verifyUrlString] cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:10.0f]; [storeRequest setHTTPMethod:@&quot;POST&quot;]; [storeRequest setHTTPBody:requestData]; // 在后台对列中提交验证请求，并获得官方的验证JSON结果 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [NSURLConnection sendAsynchronousRequest:storeRequest queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; if (connectionError) &#123; NSLog(@&quot;链接失败&quot;); &#125; else &#123; NSError *error; NSDictionary *jsonResponse = [NSJSONSerialization JSONObjectWithData:data options:0 error:&amp;error]; if (!jsonResponse) &#123; NSLog(@&quot;验证失败&quot;); &#125; // 比对 jsonResponse 中以下信息基本上可以保证数据安全 /* bundle_id application_version product_id transaction_id */ NSLog(@&quot;验证成功&quot;); &#125; &#125;]; &#125; 苹果官方文档]]></content>
      <categories>
        <category>苹果内购</category>
      </categories>
      <tags>
        <tag>IAP</tag>
        <tag>内购</tag>
      </tags>
  </entry>
</search>
